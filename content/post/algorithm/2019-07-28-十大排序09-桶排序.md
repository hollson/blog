---
title:       "十大经典排序09 - 桶排序"
description: "桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定"
date:        "2019-07-28"
author:      "布史"
image:       "img/linux.jpg"
tags:        ["算法", "排序"]
categories:  ["算法"]
archives:    "2019"
height:      9
---


# 算法介绍

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

1. 在额外空间充足的情况下，尽量增大桶的数量
2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
- 最快情况：当输入的数据可以均匀的分配到每一个桶中。
- 最慢情况：当输入的数据被分配到了同一个桶中。

# 算法示图

元素分布在桶中：

![img](https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png)

然后，元素在每个桶中排序：

![img](https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png)




# 代码实现

## 1.C代码实现
```c++
#include<stdio.h>

//桶排序最大数字
#define BUCKETSORT_MAX_NUM 1000

//桶排序 p待排序数组指针 length数组长度
int bucketSort(int *p,int length)
{
	int i,j;
	int bucket[BUCKETSORT_MAX_NUM];
	//初始化
	for(i=0;i<BUCKETSORT_MAX_NUM;i++)
	{
		bucket[i]=0;
	}
	//桶排序
	for(i=0;i<length;i++)
	{
		bucket[p[i]]++;
	}
	//输出
	for(i=0;i<BUCKETSORT_MAX_NUM;i++)
	{
		for(j=0;j<bucket[i];j++)
		{
			printf("%d ",i);
		}
	}
	return 1;
}

int main()
{
	//待排序数组
	int array[10]={1,3,5,2,4,6,10,9,8,9};	
	int sortResult=bucketSort(array,10);
	printf("\n%d",sortResult);
	return 1;
}
```

## 2.Go代码实现
```go
import (
	"fmt"
	"container/list"
)
 
func bucketSort(theArray []int,num int){
	var theSort [99]int
	for i:=0;i< len(theArray);i++{
		theSort[10]=1
		if theSort[theArray[i]] !=0{
			theSort[theArray[i]] = theSort[theArray[i]]+1
		}else{
			theSort[theArray[i]] = 1
		}
	}
	l:=list.New()
	for j:=0;j<len(theSort);j++{
		if theSort[j]==0{
			//panic("error test.....")
		}else{
			for k:=0;k<theSort[j];k++{
				l.PushBack(j)
			}
		}
	}
	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Print(e.Value, " ")
	}
 
}
 
func main() {
	var theArray = []int{10, 1, 18, 30, 23, 12, 7, 5, 18, 17}
	fmt.Print("排序前")
	fmt.Println(theArray)
	fmt.Print("排序后")
	bucketSort(theArray,11)
}
```

## 3.JS代码实现

```js
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }

    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }

    //桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }

    //利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }

    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);                      
        }
    }

    return arr;
}
```


**参考链接：**
> https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/9.bucketSort.md
>
> https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F