<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>码夫庄园-深度解密Go语言之map</title>
    <meta name="keywords"
        content='字典,map,hash,哈希,源码,内存管理'>
    <meta name="description" content="Hash table是计算机数据结构中一个最重要的设计。大部分hash table都实现了快速查找、添加、删除的功能，Go 语言内置的 map 实现了上述所有功能。map的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree）。" />

    
    <meta name="baidu-site-verification" content="v9szEmQLra" />
    <meta name="360-site-verification" content="d8e961f98fb655e4b8cf9439cfd9ac7f" />
    <meta name="sogou_site_verification" content="40NC9EdZDC" />
    <meta name="shenma-site-verification" content="3200e3042e92157713a3b0aceeecb20a_1586020187" />
    <meta name="google-site-verification" content="r8987bkunZHJeKut3ocu5NIJ5QEu53NA6Q_r7RrZ46c" />
    <meta name="msvalidate.01" content="893A2865ABC54AC2782D118536831056" />

    
    <link rel="shortcut icon" href="http://www.mafool.com/img/res/favicon.ico">
    

    

    <link crossorigin="anonymous" integrity="sha384-5kGFOAqgEKnuF6c2jk2JANKHZgYVt38Wn2dVJENtq1EBCP54/1uzXU5mpxqL8WjN"
        href="https://lib.baomitu.com/bulma/0.8.0/css/bulma.min.css" rel="stylesheet">

    <link rel="stylesheet" href="http://www.mafool.com/css/dooz.blog.css" />
    <script crossorigin="anonymous" integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh"
        src="https://lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script>

    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/jquery.share.min.js"></script>
    

    

    
    
<link rel="stylesheet" href="http://www.mafool.com/css/reward.css">


    <link href="http://www.mafool.com/css/fonts.googleapi.css" rel="stylesheet">
    <script src=http://www.mafool.com/js/dooz.blog.js></script>

    
    <script>
        $(document).ready(function () {
            $('.content a[href^="http"]').each(function () {
                $(this).attr('target', '_blank');
            });
        });

        $(document).on('click', '.modal-wechat', function () {
            $(".modal").addClass("is-active");
        });

        $(document).on('click', '.modal-background', function () {
            $(".modal").removeClass("is-active");
        });
    </script>
</head>

<body>
    
    
<section class="hero is-info is-medium"
    style="background-image: url('/img/res/bg2.jpg');">
    <div class="hero-head">
        <nav class="navbar is-transparent container has-text-white">
    <div class="navbar-brand">
        <div class="navbar-item">
            <a class="title is-5 is-white" href="http://www.mafool.com/">码夫庄园</a>
        </div>

        
        <div class="navbar-burger burger" data-target="navbarExampleTransparentExample">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <div id="navbarExampleTransparentExample" class="navbar-menu has-text-dark">
        

        <div class="navbar-end">
            <a class="navbar-item" href='http://www.mafool.com/'>首页</a>
            <a class="navbar-item" href='http://www.mafool.com/archives'>归档 </a>
            <a class="navbar-item" href='http://www.mafool.com/about'>关于</a>
            <span class="navbar-item">
                <a class="button is-primary is-inverted" href="https://github.com/hollson/hugo-theme-dooz">
                    <span class="icon"><i class="fab fa-github"></i></span>
                    <span>主题</span>
                </a>
            </span>
        </div>
    </div>
</nav>
    </div>
    <div class="hero-body">
        <div class="container has-text-centered">
            <div class='container has-text-left column is-7'>
                
                <span>
                    <a class="bar_tag" href="http://www.mafool.com/tags/map" title="map">map</a>
                </span>
                
                <span>
                    <a class="bar_tag" href="http://www.mafool.com/tags/%E6%BA%90%E7%A0%81" title="源码">源码</a>
                </span>
                
                <h1 class="title is-size-2" style="margin-bottom:0.2rem;">
                    
                    深度解密Go语言之map
                    
                </h1>
                
                <span class="title is-size-6" style="font-style: italic;"> </span><br>
            </div>
        </div>
    </div>
</section>


    
    <div class="container">
        <div class="section">
            
<div class="columns">
    <div class="column is-9">
        <div class="tile is-child box">
            <div class="content">
                
                <nav class="level">
                    
                    <div class="level-left">
                        <div class="level-item">
                            <p class="subtitle is-size-6 has-text-grey-light" style="font-style: italic;">
    
     2020年3月30日,
    星期一 &middot;
    
    <i class="far fa-clock"></i>&nbsp; 36分钟阅读
</p>
                        </div>
                    </div>

                    
                    
                    <div class="share-component level-right" data-disabled="google,diandian,tencent,qzone"
                        data-description="Share.js - 一键分享到微博，QQ空间，腾讯微博，人人，豆瓣"
                        data-mobile-sites="weibo,qq,qzone,tencent">
                    </div>
                    
                </nav>
                <hr>
                
                <header>
                    <h2>目录</h2>
                </header>
                <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#map内存模型">Map内存模型</a></li>
    <li><a href="#创建map">创建map</a></li>
    <li><a href="#哈希函数">哈希函数</a></li>
    <li><a href="#key-定位过程">key 定位过程</a></li>
    <li><a href="#map-的两种-get-操作">map 的两种 get 操作</a></li>
    <li><a href="#如何进行扩容">如何进行扩容</a></li>
    <li><a href="#map-的遍历">map 的遍历</a></li>
    <li><a href="#map-的赋值">map 的赋值</a></li>
    <li><a href="#map-的删除">map 的删除</a></li>
  </ul>

  <ul>
    <li><a href="#可以边遍历边删除吗">可以边遍历边删除吗</a></li>
    <li><a href="#key-可以是-float-型吗">key 可以是 float 型吗？</a></li>
  </ul>

  <ul>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
                
                <hr>
                <h2 id="前言">前言</h2>
<p><code>Hash table</code> 是计算机数据结构中一个最重要的设计。大部分<code>hash table</code>都实现了快速查找、添加、删除的功能，Go 语言内置的 map 实现了上述所有功能。</p>
<p>map的任务是设计一种数据结构用来维护一个集合的数据，并且可以同时对集合进行增删查改的操作。最主要的数据结构有两种：<code>哈希查找表（Hash table）</code>、<code>搜索树（Search tree）</code>。</p>
<p>哈希查找表用一个哈希函数将key分配到不同的桶（bucket，也就是数组的不同 index）。这样开销主要在哈希函数的计算以及数组的常数访问时间。在很多场景下，哈希查找表的性能很高。</p>
<p>哈希查找表一般会存在“碰撞”的问题，就是说不同的key被哈希到了同一个bucket。一般有两种应对方法：<code>链表法</code>和<code>开放地址法</code>。<code>链表法</code>将一个bucket实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。<code>开放地址法</code>则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。</p>
<p>搜索树法一般采用自平衡搜索树，包括：<code>AVL 树</code>，<code>红黑树</code>。</p>
<p>自平衡搜索树法的最差搜索效率是<code>O(logN)</code>，而哈希查找表最差是 O(N)。当然，哈希查找表的平均查找效率是 O(1)，如果哈希函数设计的很好，最坏的情况基本不会出现。还有一点，遍历自平衡搜索树，返回的key序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。</p>
<h2 id="map内存模型">Map内存模型</h2>
<p>我们可以在Github上<a href="https://github.com/golang/go/blob/master/src/runtime/map.go">查看map源码</a>；或执行<code> open -a goland $GOROOT/src/runtime/map.go</code>命令，打开本地源码(提前预装goland可go环境)。map的结构如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// A header for a Go map.
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">type</span> hmap <span style="color:#069;font-weight:bold">struct</span> {
	<span style="color:#09f;font-style:italic">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span><span style="color:#09f;font-style:italic"></span>    count     <span style="color:#078;font-weight:bold">int</span>    <span style="color:#09f;font-style:italic">//map长度，调用len(map)时，以常量返回 
</span><span style="color:#09f;font-style:italic"></span>    flags     <span style="color:#078;font-weight:bold">uint8</span>
    B         <span style="color:#078;font-weight:bold">uint8</span>  <span style="color:#09f;font-style:italic">//buckets的对数，（最多可容纳loadFactor*2^B个元素）
</span><span style="color:#09f;font-style:italic"></span>    noverflow <span style="color:#078;font-weight:bold">uint16</span> <span style="color:#09f;font-style:italic">// 溢出桶的大概数量；有关详细信息，请参见incrnoverflow
</span><span style="color:#09f;font-style:italic"></span>    hash0     <span style="color:#078;font-weight:bold">uint32</span> <span style="color:#09f;font-style:italic">// 哈希种子
</span><span style="color:#09f;font-style:italic"></span>
    buckets    unsafe.Pointer <span style="color:#09f;font-style:italic">// 2^B个桶的数组。如果count == 0，则可能为nil。
</span><span style="color:#09f;font-style:italic"></span>    oldbuckets unsafe.Pointer <span style="color:#09f;font-style:italic">// 前一个存储桶数组，其大小为一半，仅在增长时为非零
</span><span style="color:#09f;font-style:italic"></span>    nevacuate  <span style="color:#078;font-weight:bold">uintptr</span>        <span style="color:#09f;font-style:italic">// 疏散进度计数器（小于此值的存储桶已被疏散）
</span><span style="color:#09f;font-style:italic"></span>
    extra <span style="color:#555">*</span>mapextra <span style="color:#09f;font-style:italic">// 可选字段
</span><span style="color:#09f;font-style:italic"></span>}
</code></pre></td></tr></table>
</div>
</div><p>说明一下，<code>B</code> 是 buckets 数组的长度的对数，也就是说 buckets 数组的长度就是 <code>2^B</code>。</p>
<p>buckets 是一个指针，最终它指向的是一个结构体：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> bmap <span style="color:#069;font-weight:bold">struct</span> {
    tophash [bucketCnt]<span style="color:#078;font-weight:bold">uint8</span>
}
</code></pre></td></tr></table>
</div>
</div><p>但这只是表面的结构，编译期间会给它加料，动态地创建一个新的结构：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> bmap <span style="color:#069;font-weight:bold">struct</span> {
    topbits  [<span style="color:#f60">8</span>]<span style="color:#078;font-weight:bold">uint8</span>
    keys     [<span style="color:#f60">8</span>]keytype
    values   [<span style="color:#f60">8</span>]valuetype
    pad      <span style="color:#078;font-weight:bold">uintptr</span>
    overflow <span style="color:#078;font-weight:bold">uintptr</span>
}
</code></pre></td></tr></table>
</div>
</div><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。</p>
<p>整体架构如下：<br>
<img src="http://mmbiz.qpic.cn/mmbiz_png/Mzws9oBx0P6htYtZtsWgQZ69iaY1M34HcQuF1Sc7xt776jCI2IM2J2JJIFwxibjia8Naqq0SPWWTxLdibKVlYeRrWg/640" alt=""></p>
<p><img src="https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png" alt="map结构"></p>
<p><strong>当map的key和value都不是指针，并且size都小于128字节的情况下，会把bmap标记为不含指针，这样可以避免gc时扫描整个hmap</strong>。但是，我们看bmap其实有一个overflow的字段，是指针类型的，破坏了bmap不含指针的设想，这时会把overflow移动到extra字段来。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> mapextra <span style="color:#069;font-weight:bold">struct</span> {
	<span style="color:#09f;font-style:italic">// overflow[0] contains overflow buckets for hmap.buckets.
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// overflow[1] contains overflow buckets for hmap.oldbuckets.
</span><span style="color:#09f;font-style:italic"></span>	overflow [<span style="color:#f60">2</span>]<span style="color:#555">*</span>[]<span style="color:#555">*</span>bmap

	<span style="color:#09f;font-style:italic">// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket
</span><span style="color:#09f;font-style:italic"></span>	nextOverflow <span style="color:#555">*</span>bmap
}
</code></pre></td></tr></table>
</div>
</div><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。<br>
<img src="https://user-images.githubusercontent.com/7698088/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e.png" alt=""></p>
<p>上图就是 bucket 的内存模型，<code>HOB Hash</code> 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p>
<p>例如，有这样一个类型的 map：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">int64</span>]<span style="color:#078;font-weight:bold">int8</span>
</code></pre></td></tr></table>
</div>
</div><p>如果按照 <code>key/value/key/value/...</code> 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 padding。</p>
<p>每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 <code>overflow</code> 指针连接起来。</p>
<h2 id="创建map">创建map</h2>
<p>从语法层面上来说，创建 map 很简单：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go">ageMp <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">string</span>]<span style="color:#078;font-weight:bold">int</span>)
<span style="color:#09f;font-style:italic">// 指定 map 长度
</span><span style="color:#09f;font-style:italic"></span>ageMp <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">string</span>]<span style="color:#078;font-weight:bold">int</span>, <span style="color:#f60">8</span>)

<span style="color:#09f;font-style:italic">// ageMp 为 nil，不能向其添加元素，会直接panic
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">var</span> ageMp <span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">string</span>]<span style="color:#078;font-weight:bold">int</span>
</code></pre></td></tr></table>
</div>
</div><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">makemap</span>(t <span style="color:#555">*</span>maptype, hint <span style="color:#078;font-weight:bold">int64</span>, h <span style="color:#555">*</span>hmap, bucket unsafe.Pointer) <span style="color:#555">*</span>hmap {
	<span style="color:#09f;font-style:italic">// 省略各种条件检查...
</span><span style="color:#09f;font-style:italic"></span>
	<span style="color:#09f;font-style:italic">// 找到一个 B，使得 map 的装载因子在正常范围内
</span><span style="color:#09f;font-style:italic"></span>	B <span style="color:#555">:=</span> <span style="color:#366">uint8</span>(<span style="color:#f60">0</span>)
	<span style="color:#069;font-weight:bold">for</span> ; <span style="color:#c0f">overLoadFactor</span>(hint, B); B<span style="color:#555">++</span> {
	}

	<span style="color:#09f;font-style:italic">// 初始化 hash table
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 如果长度比较大，分配内存会花费长一点
</span><span style="color:#09f;font-style:italic"></span>	buckets <span style="color:#555">:=</span> bucket
	<span style="color:#069;font-weight:bold">var</span> extra <span style="color:#555">*</span>mapextra
	<span style="color:#069;font-weight:bold">if</span> B <span style="color:#555">!=</span> <span style="color:#f60">0</span> {
		<span style="color:#069;font-weight:bold">var</span> nextOverflow <span style="color:#555">*</span>bmap
		buckets, nextOverflow = <span style="color:#c0f">makeBucketArray</span>(t, B)
		<span style="color:#069;font-weight:bold">if</span> nextOverflow <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
			extra = <span style="color:#366">new</span>(mapextra)
			extra.nextOverflow = nextOverflow
		}
	}

	<span style="color:#09f;font-style:italic">// 初始化 hamp
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> h <span style="color:#555">==</span> <span style="color:#069;font-weight:bold">nil</span> {
		h = (<span style="color:#555">*</span>hmap)(<span style="color:#c0f">newobject</span>(t.hmap))
	}
	h.count = <span style="color:#f60">0</span>
	h.B = B
	h.extra = extra
	h.flags = <span style="color:#f60">0</span>
	h.hash0 = <span style="color:#c0f">fastrand</span>()
	h.buckets = buckets
	h.oldbuckets = <span style="color:#069;font-weight:bold">nil</span>
	h.nevacuate = <span style="color:#f60">0</span>
	h.noverflow = <span style="color:#f60">0</span>

	<span style="color:#069;font-weight:bold">return</span> h
}
</code></pre></td></tr></table>
</div>
</div><p>注意，这个函数返回的结果：<code>*hmap</code>，它是一个指针，而我们之前讲过的 <code>makeslice</code> 函数返回的是 <code>Slice</code> 结构体：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func makeslice(et *_type, len, cap int) slice
</code></pre></td></tr></table>
</div>
</div><p>回顾一下 slice 的结构体定义：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}
</code></pre></td></tr></table>
</div>
</div><p>结构体内部包含底层的数据指针。</p>
<p>makemap 和 makeslice 的区别，带来一个不同点：当 map 和 slice 作为函数参数时，在函数参数内部对 map 的操作会影响 map 自身；而对 slice 却不会（之前讲 slice 的文章里有讲过）。</p>
<p>主要原因：一个是指针（<code>*hmap</code>），一个是结构体（<code>slice</code>）。Go 语言中的函数传参都是值传递，在函数内部，参数会被 copy 到本地。<code>*hmap</code>指针 copy 完之后，仍然指向同一个 map，因此函数内部对 map 的操作会影响实参。而 slice 被 copy 后，会成为一个新的 slice，对它进行的操作不会影响到实参。</p>
<h2 id="哈希函数">哈希函数</h2>
<p>map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 <code>alginit()</code> 中完成，位于路径：<code>src/runtime/alg.go</code> 下。</p>
<blockquote>
<p>hash 函数，有加密型和非加密型。<br>
加密型的一般用于加密数据、数字摘要等，典型代表就是 md5、sha1、sha256、aes256 这种；<br>
非加密型的一般就是查找。在 map 的应用场景中，用的是查找。<br>
选择 hash 函数主要考察的是两点：性能、碰撞概率。</p>
</blockquote>
<p>之前我们讲过，表示类型的结构体：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> _type <span style="color:#069;font-weight:bold">struct</span> {
	size       <span style="color:#078;font-weight:bold">uintptr</span>
	ptrdata    <span style="color:#078;font-weight:bold">uintptr</span> <span style="color:#09f;font-style:italic">// size of memory prefix holding all pointers
</span><span style="color:#09f;font-style:italic"></span>	hash       <span style="color:#078;font-weight:bold">uint32</span>
	tflag      tflag
	align      <span style="color:#078;font-weight:bold">uint8</span>
	fieldalign <span style="color:#078;font-weight:bold">uint8</span>
	kind       <span style="color:#078;font-weight:bold">uint8</span>
	alg        <span style="color:#555">*</span>typeAlg
	gcdata    <span style="color:#555">*</span><span style="color:#078;font-weight:bold">byte</span>
	str       nameOff
	ptrToThis typeOff
}
</code></pre></td></tr></table>
</div>
</div><p>其中 <code>alg</code> 字段就和哈希相关，它是指向如下结构体的指针：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// src/runtime/alg.go
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">type</span> typeAlg <span style="color:#069;font-weight:bold">struct</span> {
	<span style="color:#09f;font-style:italic">// (ptr to object, seed) -&gt; hash
</span><span style="color:#09f;font-style:italic"></span>	hash <span style="color:#069;font-weight:bold">func</span>(unsafe.Pointer, <span style="color:#078;font-weight:bold">uintptr</span>) <span style="color:#078;font-weight:bold">uintptr</span>
	<span style="color:#09f;font-style:italic">// (ptr to object A, ptr to object B) -&gt; ==?
</span><span style="color:#09f;font-style:italic"></span>	equal <span style="color:#069;font-weight:bold">func</span>(unsafe.Pointer, unsafe.Pointer) <span style="color:#078;font-weight:bold">bool</span>
}
</code></pre></td></tr></table>
</div>
</div><p>typeAlg 包含两个函数，hash 函数计算类型的哈希值，而 equal 函数则计算两个类型是否“哈希相等”。</p>
<p>对于 string 类型，它的 hash、equal 函数如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">strhash</span>(a unsafe.Pointer, h <span style="color:#078;font-weight:bold">uintptr</span>) <span style="color:#078;font-weight:bold">uintptr</span> {
	x <span style="color:#555">:=</span> (<span style="color:#555">*</span>stringStruct)(a)
	<span style="color:#069;font-weight:bold">return</span> <span style="color:#c0f">memhash</span>(x.str, h, <span style="color:#366">uintptr</span>(x.len))
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">strequal</span>(p, q unsafe.Pointer) <span style="color:#078;font-weight:bold">bool</span> {
	<span style="color:#069;font-weight:bold">return</span> <span style="color:#555">*</span>(<span style="color:#555">*</span><span style="color:#078;font-weight:bold">string</span>)(p) <span style="color:#555">==</span> <span style="color:#555">*</span>(<span style="color:#555">*</span><span style="color:#078;font-weight:bold">string</span>)(q)
}
</code></pre></td></tr></table>
</div>
</div><p>根据 key 的类型，_type 结构体的 alg 字段会被设置对应类型的 hash 和 equal 函数。</p>
<h2 id="key-定位过程">key 定位过程</h2>
<p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p>
<p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
</code></pre></td></tr></table>
</div>
</div><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p>
<p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p>
<p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p>
<p>这里参考曹大 github 博客里的一张图，原图是 ascii 图，geek 味十足，可以从参考资料找到曹大的博客，推荐大家去看看。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57577721-faf57580-74af-11e9-8826-aacdb34a1d2b.png"><img src="https://user-images.githubusercontent.com/7698088/57577721-faf57580-74af-11e9-8826-aacdb34a1d2b.png" alt="mapacess"></a>mapacess</p>
<p>上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 <code>00110</code>，找到对应的 6 号 bucket，使用高 8 位 <code>10010111</code>，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p>
<p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p>
<p>我们来看下源码吧，哈哈！通过汇编语言可以看到，查找某个 key 的底层函数是 <code>mapacess</code> 系列函数，函数的作用类似，区别在下一节会讲到。这里我们直接看 <code>mapacess1</code> 函数：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">71
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">72
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">73
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">74
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">75
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">76
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">77
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">78
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">79
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">80
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">81
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">82
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">83
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">84
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">85
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">86
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">87
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">88
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">89
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">mapaccess1</span>(t <span style="color:#555">*</span>maptype, h <span style="color:#555">*</span>hmap, key unsafe.Pointer) unsafe.Pointer {
	<span style="color:#09f;font-style:italic">// ……
</span><span style="color:#09f;font-style:italic"></span>	
	<span style="color:#09f;font-style:italic">// 如果 h 什么都没有，返回零值
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> h <span style="color:#555">==</span> <span style="color:#069;font-weight:bold">nil</span> <span style="color:#555">||</span> h.count <span style="color:#555">==</span> <span style="color:#f60">0</span> {
		<span style="color:#069;font-weight:bold">return</span> unsafe.<span style="color:#c0f">Pointer</span>(<span style="color:#555">&amp;</span>zeroVal[<span style="color:#f60">0</span>])
	}
	
	<span style="color:#09f;font-style:italic">// 写和读冲突
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> h.flags<span style="color:#555">&amp;</span>hashWriting <span style="color:#555">!=</span> <span style="color:#f60">0</span> {
		<span style="color:#c0f">throw</span>(<span style="color:#c30">&#34;concurrent map read and map write&#34;</span>)
	}
	
	<span style="color:#09f;font-style:italic">// 不同类型 key 使用的 hash 算法在编译期确定
</span><span style="color:#09f;font-style:italic"></span>	alg <span style="color:#555">:=</span> t.key.alg
	
	<span style="color:#09f;font-style:italic">// 计算哈希值，并且加入 hash0 引入随机性
</span><span style="color:#09f;font-style:italic"></span>	hash <span style="color:#555">:=</span> alg.<span style="color:#c0f">hash</span>(key, <span style="color:#366">uintptr</span>(h.hash0))
	
	<span style="color:#09f;font-style:italic">// 比如 B=5，那 m 就是31，二进制是全 1
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 求 bucket num 时，将 hash 与 m 相与，
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 达到 bucket num 由 hash 的低 8 位决定的效果
</span><span style="color:#09f;font-style:italic"></span>	m <span style="color:#555">:=</span> <span style="color:#366">uintptr</span>(<span style="color:#f60">1</span>)<span style="color:#555">&lt;&lt;</span>h.B <span style="color:#555">-</span> <span style="color:#f60">1</span>
	
	<span style="color:#09f;font-style:italic">// b 就是 bucket 的地址
</span><span style="color:#09f;font-style:italic"></span>	b <span style="color:#555">:=</span> (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(h.buckets, (hash<span style="color:#555">&amp;</span>m)<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
	
	<span style="color:#09f;font-style:italic">// oldbuckets 不为 nil，说明发生了扩容
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> c <span style="color:#555">:=</span> h.oldbuckets; c <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
	    <span style="color:#09f;font-style:italic">// 如果不是同 size 扩容（看后面扩容的内容）
</span><span style="color:#09f;font-style:italic"></span>	    <span style="color:#09f;font-style:italic">// 对应条件 1 的解决方案
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> !h.<span style="color:#c0f">sameSizeGrow</span>() {
			<span style="color:#09f;font-style:italic">// 新 bucket 数量是老的 2 倍
</span><span style="color:#09f;font-style:italic"></span>			m <span style="color:#555">&gt;&gt;=</span> <span style="color:#f60">1</span>
		}
		
		<span style="color:#09f;font-style:italic">// 求出 key 在老的 map 中的 bucket 位置
</span><span style="color:#09f;font-style:italic"></span>		oldb <span style="color:#555">:=</span> (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(c, (hash<span style="color:#555">&amp;</span>m)<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
		
		<span style="color:#09f;font-style:italic">// 如果 oldb 没有搬迁到新的 bucket
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// 那就在老的 bucket 中寻找
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> !<span style="color:#c0f">evacuated</span>(oldb) {
			b = oldb
		}
	}
	
	<span style="color:#09f;font-style:italic">// 计算出高 8 位的 hash
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 相当于右移 56 位，只取高8位
</span><span style="color:#09f;font-style:italic"></span>	top <span style="color:#555">:=</span> <span style="color:#366">uint8</span>(hash <span style="color:#555">&gt;&gt;</span> (sys.PtrSize<span style="color:#555">*</span><span style="color:#f60">8</span> <span style="color:#555">-</span> <span style="color:#f60">8</span>))
	
	<span style="color:#09f;font-style:italic">// 增加一个 minTopHash
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> top &lt; minTopHash {
		top <span style="color:#555">+=</span> minTopHash
	}
	<span style="color:#069;font-weight:bold">for</span> {
	    <span style="color:#09f;font-style:italic">// 遍历 8 个 bucket
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">for</span> i <span style="color:#555">:=</span> <span style="color:#366">uintptr</span>(<span style="color:#f60">0</span>); i &lt; bucketCnt; i<span style="color:#555">++</span> {
		    <span style="color:#09f;font-style:italic">// tophash 不匹配，继续
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">if</span> b.tophash[i] <span style="color:#555">!=</span> top {
				<span style="color:#069;font-weight:bold">continue</span>
			}
			<span style="color:#09f;font-style:italic">// tophash 匹配，定位到 key 的位置
</span><span style="color:#09f;font-style:italic"></span>			k <span style="color:#555">:=</span> <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(b), dataOffset<span style="color:#555">+</span>i<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize))
			<span style="color:#09f;font-style:italic">// key 是指针
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">if</span> t.indirectkey {
			    <span style="color:#09f;font-style:italic">// 解引用
</span><span style="color:#09f;font-style:italic"></span>				k = <span style="color:#555">*</span>((<span style="color:#555">*</span>unsafe.Pointer)(k))
			}
			<span style="color:#09f;font-style:italic">// 如果 key 相等
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">if</span> alg.<span style="color:#c0f">equal</span>(key, k) {
			    <span style="color:#09f;font-style:italic">// 定位到 value 的位置
</span><span style="color:#09f;font-style:italic"></span>				v <span style="color:#555">:=</span> <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(b), dataOffset<span style="color:#555">+</span>bucketCnt<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize)<span style="color:#555">+</span>i<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.valuesize))
				<span style="color:#09f;font-style:italic">// value 解引用
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> t.indirectvalue {
					v = <span style="color:#555">*</span>((<span style="color:#555">*</span>unsafe.Pointer)(v))
				}
				<span style="color:#069;font-weight:bold">return</span> v
			}
		}
		
		<span style="color:#09f;font-style:italic">// bucket 找完（还没找到），继续到 overflow bucket 里找
</span><span style="color:#09f;font-style:italic"></span>		b = b.<span style="color:#c0f">overflow</span>(t)
		<span style="color:#09f;font-style:italic">// overflow bucket 也找完了，说明没有目标 key
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// 返回零值
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> b <span style="color:#555">==</span> <span style="color:#069;font-weight:bold">nil</span> {
			<span style="color:#069;font-weight:bold">return</span> unsafe.<span style="color:#c0f">Pointer</span>(<span style="color:#555">&amp;</span>zeroVal[<span style="color:#f60">0</span>])
		}
	}
}
</code></pre></td></tr></table>
</div>
</div><p>函数返回 h[key] 的指针，如果 h 中没有此 key，那就会返回一个 key 相应类型的零值，不会返回 nil。</p>
<p>代码整体比较直接，没什么难懂的地方。跟着上面的注释一步步理解就好了。</p>
<p>这里，说一下定位 key 和 value 的方法以及整个循环的写法。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// key 定位公式
k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))

// value 定位公式
v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
</code></pre></td></tr></table>
</div>
</div><p>b 是 bmap 的地址，这里 bmap 还是源码里定义的结构体，只包含一个 tophash 数组，经编译器扩充之后的结构体才包含 key，value，overflow 这些字段。dataOffset 是 key 相对于 bmap 起始地址的偏移：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">dataOffset = unsafe.Offsetof(struct {
		b bmap
		v int64
	}{}.v)
</code></pre></td></tr></table>
</div>
</div><p>因此 bucket 里 key 的起始地址就是 unsafe.Pointer(b)+dataOffset。第 i 个 key 的地址就要在此基础上跨过 i 个 key 的大小；而我们又知道，value 的地址是在所有 key 之后，因此第 i 个 value 的地址还需要加上所有 key 的偏移。理解了这些，上面 key 和 value 的定位公式就很好理解了。</p>
<p>再说整个大循环的写法，最外层是一个无限循环，通过</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">b = b.overflow(t)
</code></pre></td></tr></table>
</div>
</div><p>遍历所有的 bucket，这相当于是一个 bucket 链表。</p>
<p>当定位到一个具体的 bucket 时，里层循环就是遍历这个 bucket 里所有的 cell，或者说所有的槽位，也就是 bucketCnt=8 个槽位。整个循环过程：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57581783-fe5c2180-74ee-11e9-99c9-5a226216e1af.png"><img src="https://user-images.githubusercontent.com/7698088/57581783-fe5c2180-74ee-11e9-99c9-5a226216e1af.png" alt="mapacess loop"></a>mapacess loop</p>
<p>再说一下 minTopHash，当一个 cell 的 tophash 值小于 minTopHash 时，标志这个 cell 的迁移状态。因为这个状态值是放在 tophash 数组里，为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。</p>
<p>下面的这几种状态就表征了 bucket 的情况：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// 空的 cell，也是初始时 bucket 的状态
empty          = 0
// 空的 cell，表示 cell 已经被迁移到新的 bucket
evacuatedEmpty = 1
// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，
// 后面扩容部分会再讲到。
evacuatedX     = 2
// 同上，key 在后半部分
evacuatedY     = 3
// tophash 的最小正常值
minTopHash     = 4
</code></pre></td></tr></table>
</div>
</div><p>源码里判断这个 bucket 是否已经搬迁完毕，用到的函数：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h &gt; empty &amp;&amp; h &lt; minTopHash
}
</code></pre></td></tr></table>
</div>
</div><p>只取了 tophash 数组的第一个值，判断它是否在 0-4 之间。对比上面的常量，当 top hash 是 <code>evacuatedEmpty</code>、<code>evacuatedX</code>、<code>evacuatedY</code> 这三个值之一，说明此 bucket 中的 key 全部被搬迁到了新 bucket。</p>
<h2 id="map-的两种-get-操作">map 的两种 get 操作</h2>
<p>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 value 类型的零值。如果 value 是 int 型就会返回 0，如果 value 是 string 类型，就会返回空字符串。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> main

<span style="color:#069;font-weight:bold">import</span> <span style="color:#c30">&#34;fmt&#34;</span>

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
	ageMap <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">string</span>]<span style="color:#078;font-weight:bold">int</span>)
	ageMap[<span style="color:#c30">&#34;qcrao&#34;</span>] = <span style="color:#f60">18</span>

    <span style="color:#09f;font-style:italic">// 不带 comma 用法
</span><span style="color:#09f;font-style:italic"></span>	age1 <span style="color:#555">:=</span> ageMap[<span style="color:#c30">&#34;stefno&#34;</span>]
	fmt.<span style="color:#c0f">Println</span>(age1)

    <span style="color:#09f;font-style:italic">// 带 comma 用法
</span><span style="color:#09f;font-style:italic"></span>	age2, ok <span style="color:#555">:=</span> ageMap[<span style="color:#c30">&#34;stefno&#34;</span>]
	fmt.<span style="color:#c0f">Println</span>(age2, ok)
}
</code></pre></td></tr></table>
</div>
</div><p>运行结果：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">0
0 false
</code></pre></td></tr></table>
</div>
</div><p>以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// src/runtime/hashmap.go
func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)
</code></pre></td></tr></table>
</div>
</div><p>源码里，函数命名不拘小节，直接带上后缀 1，2，完全不理会《代码大全》里的那一套命名的做法。从上面两个函数的声明也可以看出差别了，<code>mapaccess2</code> 函数返回值多了一个 bool 型变量，两者的代码也是完全一样的，只是在返回值后面多加了一个 false 或者 true。</p>
<p>另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：</p>
<table>
<thead>
<tr>
<th>key 类型</th>
<th>查找</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td>uint32</td>
<td>mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)</td>
</tr>
</tbody>
</table>
<p>这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。</p>
<p>上面这些函数都是在文件 <code>src/runtime/hashmap_fast.go</code> 里。</p>
<h2 id="如何进行扩容">如何进行扩容</h2>
<p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 <code>O(1)</code> 的效率，但这样空间消耗太大，用空间换时间的代价太高。</p>
<p>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。</p>
<p>当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。</p>
<p>因此，需要有一个指标来衡量前面描述的情况，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">loadFactor := count / (2^B)
</code></pre></td></tr></table>
</div>
</div><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p>
<p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p>
<ol>
<li>装载因子超过阈值，源码里定义的阈值是 6.5。</li>
<li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li>
</ol>
<p>通过汇编语言可以找到赋值操作对应源码中的函数是 <code>mapassign</code>，对应扩容条件的源码如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// src/runtime/hashmap.go/mapassign
</span><span style="color:#09f;font-style:italic"></span>
<span style="color:#09f;font-style:italic">// 触发扩容时机
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">if</span> !h.<span style="color:#c0f">growing</span>() <span style="color:#555">&amp;&amp;</span> (<span style="color:#c0f">overLoadFactor</span>(<span style="color:#366">int64</span>(h.count), h.B) <span style="color:#555">||</span> <span style="color:#c0f">tooManyOverflowBuckets</span>(h.noverflow, h.B)) {
		<span style="color:#c0f">hashGrow</span>(t, h)
	}

<span style="color:#09f;font-style:italic">// 装载因子超过 6.5
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">overLoadFactor</span>(count <span style="color:#078;font-weight:bold">int64</span>, B <span style="color:#078;font-weight:bold">uint8</span>) <span style="color:#078;font-weight:bold">bool</span> {
	<span style="color:#069;font-weight:bold">return</span> count <span style="color:#555">&gt;=</span> bucketCnt <span style="color:#555">&amp;&amp;</span> <span style="color:#366">float32</span>(count) <span style="color:#555">&gt;=</span> loadFactor<span style="color:#555">*</span><span style="color:#366">float32</span>((<span style="color:#366">uint64</span>(<span style="color:#f60">1</span>)<span style="color:#555">&lt;&lt;</span>B))
}

<span style="color:#09f;font-style:italic">// overflow buckets 太多
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">tooManyOverflowBuckets</span>(noverflow <span style="color:#078;font-weight:bold">uint16</span>, B <span style="color:#078;font-weight:bold">uint8</span>) <span style="color:#078;font-weight:bold">bool</span> {
	<span style="color:#069;font-weight:bold">if</span> B &lt; <span style="color:#f60">16</span> {
		<span style="color:#069;font-weight:bold">return</span> noverflow <span style="color:#555">&gt;=</span> <span style="color:#366">uint16</span>(<span style="color:#f60">1</span>)<span style="color:#555">&lt;&lt;</span>B
	}
	<span style="color:#069;font-weight:bold">return</span> noverflow <span style="color:#555">&gt;=</span> <span style="color:#f60">1</span><span style="color:#555">&lt;&lt;</span><span style="color:#f60">15</span>
}
</code></pre></td></tr></table>
</div>
</div><p>解释一下：</p>
<p>第 1 点：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p>
<p>第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p>
<p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p>
<p>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。</p>
<p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p>
<p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p>
<p>对于条件 2 的解决方案，曹大的博客里还提出了一个极端的情况：如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。</p>
<p>再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p>
<p>上面说的 <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p>
<p>我们先看 <code>hashGrow()</code> 函数所做的工作，再来看具体的搬迁 buckets 是如何进行的。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">hashGrow</span>(t <span style="color:#555">*</span>maptype, h <span style="color:#555">*</span>hmap) {
	<span style="color:#09f;font-style:italic">// B+1 相当于是原来 2 倍的空间
</span><span style="color:#09f;font-style:italic"></span>	bigger <span style="color:#555">:=</span> <span style="color:#366">uint8</span>(<span style="color:#f60">1</span>)

	<span style="color:#09f;font-style:italic">// 对应条件 2
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> !<span style="color:#c0f">overLoadFactor</span>(<span style="color:#366">int64</span>(h.count), h.B) {
		<span style="color:#09f;font-style:italic">// 进行等量的内存扩容，所以 B 不变
</span><span style="color:#09f;font-style:italic"></span>		bigger = <span style="color:#f60">0</span>
		h.flags <span style="color:#555">|=</span> sameSizeGrow
	}
	<span style="color:#09f;font-style:italic">// 将老 buckets 挂到 buckets 上
</span><span style="color:#09f;font-style:italic"></span>	oldbuckets <span style="color:#555">:=</span> h.buckets
	<span style="color:#09f;font-style:italic">// 申请新的 buckets 空间
</span><span style="color:#09f;font-style:italic"></span>	newbuckets, nextOverflow <span style="color:#555">:=</span> <span style="color:#c0f">makeBucketArray</span>(t, h.B<span style="color:#555">+</span>bigger)

	flags <span style="color:#555">:=</span> h.flags <span style="color:#555">&amp;^</span> (iterator | oldIterator)
	<span style="color:#069;font-weight:bold">if</span> h.flags<span style="color:#555">&amp;</span>iterator <span style="color:#555">!=</span> <span style="color:#f60">0</span> {
		flags <span style="color:#555">|=</span> oldIterator
	}
	<span style="color:#09f;font-style:italic">// 提交 grow 的动作
</span><span style="color:#09f;font-style:italic"></span>	h.B <span style="color:#555">+=</span> bigger
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	<span style="color:#09f;font-style:italic">// 搬迁进度为 0
</span><span style="color:#09f;font-style:italic"></span>	h.nevacuate = <span style="color:#f60">0</span>
	<span style="color:#09f;font-style:italic">// overflow buckets 数为 0
</span><span style="color:#09f;font-style:italic"></span>	h.noverflow = <span style="color:#f60">0</span>

	<span style="color:#09f;font-style:italic">// ……
</span><span style="color:#09f;font-style:italic"></span>}
</code></pre></td></tr></table>
</div>
</div><p>主要是申请到了新的 buckets 空间，把相关的标志位都进行了处理：例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。</p>
<p>值得一说的是对 <code>h.flags</code> 的处理：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">flags := h.flags &amp;^ (iterator | oldIterator)
if h.flags&amp;iterator != 0 {
	flags |= oldIterator
}
</code></pre></td></tr></table>
</div>
</div><p>这里得先说下运算符：&amp;^。这叫<code>按位置 0</code>运算符。例如：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">x = 01010011
y = 01010100
z = x &amp;^ y = 00000011
</code></pre></td></tr></table>
</div>
</div><p>如果 y bit 位为 1，那么结果 z 对应 bit 位就为 0，否则 z 对应 bit 位就和 x 对应 bit 位的值相同。</p>
<p>所以上面那段对 flags 一顿操作的代码的意思是：先把 h.flags 中 iterator 和 oldIterator 对应位清 0，然后如果发现 iterator 位为 1，那就把它转接到 oldIterator 位，使得 oldIterator 标志位变成 1。潜台词就是：buckets 现在挂到了 oldBuckets 名下了，对应的标志位也转接过去吧。</p>
<p>几个标志位如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// 可能有迭代器使用 buckets
iterator     = 1
// 可能有迭代器使用 oldbuckets
oldIterator  = 2
// 有协程正在向 map 中写入 key
hashWriting  = 4
// 等量扩容（对应条件 2）
sameSizeGrow = 8
</code></pre></td></tr></table>
</div>
</div><p>再来看看真正执行搬迁工作的 growWork() 函数。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func growWork(t *maptype, h *hmap, bucket uintptr) {
	// 确认搬迁老的 bucket 对应正在使用的 bucket
	evacuate(t, h, bucket&amp;h.oldbucketmask())

	// 再搬迁一个 bucket，以加快搬迁进程
	if h.growing() {
		evacuate(t, h, h.nevacuate)
	}
}
</code></pre></td></tr></table>
</div>
</div><p>h.growing() 函数非常简单：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func (h *hmap) growing() bool {
	return h.oldbuckets != nil
}
</code></pre></td></tr></table>
</div>
</div><p>如果 <code>oldbuckets</code> 不为空，说明还没有搬迁完毕，还得继续搬。</p>
<p><code>bucket&amp;h.oldbucketmask()</code> 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。<code>oldbucketmask()</code> 函数返回扩容前的 map 的 bucketmask。</p>
<p>所谓的 bucketmask，作用就是将 key 计算出来的哈希值与 bucketmask 相与，得到的结果就是 key 应该落入的桶。比如 B = 5，那么 bucketmask 的低 5 位是 <code>11111</code>，其余位是 <code>0</code>，hash 值与其相与的意思是，只有 hash 值的低 5 位决策 key 到底落入哪个 bucket。</p>
<p>接下来，我们集中所有的精力在搬迁的关键函数 evacuate。源码贴在下面，不要紧张，我会加上大面积的注释，通过注释绝对是能看懂的。之后，我会再对搬迁过程作详细说明。</p>
<p>源码如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">  9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 71
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 72
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 73
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 74
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 75
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 76
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 77
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 78
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 79
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 80
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 81
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 82
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 83
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 84
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 85
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 86
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 87
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 88
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 89
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 90
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 91
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 92
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 93
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 94
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 95
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 96
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 97
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 98
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 99
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">100
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">101
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">102
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">103
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">104
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">105
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">106
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">107
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">108
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">109
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">110
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">111
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">112
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">113
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">114
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">115
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">116
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">117
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">118
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">119
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">120
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">121
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">122
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">123
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">124
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">125
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">126
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">127
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">128
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">129
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">130
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">131
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">132
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">133
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">134
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">135
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">136
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">137
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">138
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">139
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">140
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">141
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">142
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">143
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">144
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">145
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">146
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">147
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">148
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">149
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">150
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">151
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">152
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">153
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">154
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">155
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">156
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">157
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">158
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">159
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">160
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">161
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">162
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">163
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">164
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">165
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">166
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">167
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">168
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">169
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">170
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">171
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">172
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">173
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">174
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">175
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">176
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">177
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">178
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">179
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">180
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">181
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">182
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">183
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">184
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">185
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">186
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">187
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">evacuate</span>(t <span style="color:#555">*</span>maptype, h <span style="color:#555">*</span>hmap, oldbucket <span style="color:#078;font-weight:bold">uintptr</span>) {
	<span style="color:#09f;font-style:italic">// 定位老的 bucket 地址
</span><span style="color:#09f;font-style:italic"></span>	b <span style="color:#555">:=</span> (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(h.oldbuckets, oldbucket<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
	<span style="color:#09f;font-style:italic">// 结果是 2^B，如 B = 5，结果为32
</span><span style="color:#09f;font-style:italic"></span>	newbit <span style="color:#555">:=</span> h.<span style="color:#c0f">noldbuckets</span>()
	<span style="color:#09f;font-style:italic">// key 的哈希函数
</span><span style="color:#09f;font-style:italic"></span>	alg <span style="color:#555">:=</span> t.key.alg
	<span style="color:#09f;font-style:italic">// 如果 b 没有被搬迁过
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> !<span style="color:#c0f">evacuated</span>(b) {
		<span style="color:#069;font-weight:bold">var</span> (
			<span style="color:#09f;font-style:italic">// 表示bucket 移动的目标地址
</span><span style="color:#09f;font-style:italic"></span>			x, y   <span style="color:#555">*</span>bmap
			<span style="color:#09f;font-style:italic">// 指向 x,y 中的 key/val
</span><span style="color:#09f;font-style:italic"></span>			xi, yi <span style="color:#078;font-weight:bold">int</span>
			<span style="color:#09f;font-style:italic">// 指向 x，y 中的 key
</span><span style="color:#09f;font-style:italic"></span>			xk, yk unsafe.Pointer
			<span style="color:#09f;font-style:italic">// 指向 x，y 中的 value
</span><span style="color:#09f;font-style:italic"></span>			xv, yv unsafe.Pointer
		)
		<span style="color:#09f;font-style:italic">// 默认是等 size 扩容，前后 bucket 序号不变
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// 使用 x 来进行搬迁
</span><span style="color:#09f;font-style:italic"></span>		x = (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(h.buckets, oldbucket<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
		xi = <span style="color:#f60">0</span>
		xk = <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(x), dataOffset)
		xv = <span style="color:#c0f">add</span>(xk, bucketCnt<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize))<span style="color:#a00;background-color:#faa">、</span>

		<span style="color:#09f;font-style:italic">// 如果不是等 size 扩容，前后 bucket 序号有变
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// 使用 y 来进行搬迁
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> !h.<span style="color:#c0f">sameSizeGrow</span>() {
			<span style="color:#09f;font-style:italic">// y 代表的 bucket 序号增加了 2^B
</span><span style="color:#09f;font-style:italic"></span>			y = (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(h.buckets, (oldbucket<span style="color:#555">+</span>newbit)<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
			yi = <span style="color:#f60">0</span>
			yk = <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(y), dataOffset)
			yv = <span style="color:#c0f">add</span>(yk, bucketCnt<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize))
		}

		<span style="color:#09f;font-style:italic">// 遍历所有的 bucket，包括 overflow buckets
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// b 是老的 bucket 地址
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">for</span> ; b <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span>; b = b.<span style="color:#c0f">overflow</span>(t) {
			k <span style="color:#555">:=</span> <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(b), dataOffset)
			v <span style="color:#555">:=</span> <span style="color:#c0f">add</span>(k, bucketCnt<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize))

			<span style="color:#09f;font-style:italic">// 遍历 bucket 中的所有 cell
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">for</span> i <span style="color:#555">:=</span> <span style="color:#f60">0</span>; i &lt; bucketCnt; i, k, v = i<span style="color:#555">+</span><span style="color:#f60">1</span>, <span style="color:#c0f">add</span>(k, <span style="color:#366">uintptr</span>(t.keysize)), <span style="color:#c0f">add</span>(v, <span style="color:#366">uintptr</span>(t.valuesize)) {
				<span style="color:#09f;font-style:italic">// 当前 cell 的 top hash 值
</span><span style="color:#09f;font-style:italic"></span>				top <span style="color:#555">:=</span> b.tophash[i]
				<span style="color:#09f;font-style:italic">// 如果 cell 为空，即没有 key
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> top <span style="color:#555">==</span> empty {
					<span style="color:#09f;font-style:italic">// 那就标志它被&#34;搬迁&#34;过
</span><span style="color:#09f;font-style:italic"></span>					b.tophash[i] = evacuatedEmpty
					<span style="color:#09f;font-style:italic">// 继续下个 cell
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#069;font-weight:bold">continue</span>
				}
				<span style="color:#09f;font-style:italic">// 正常不会出现这种情况
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#09f;font-style:italic">// 未被搬迁的 cell 只可能是 empty 或是
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#09f;font-style:italic">// 正常的 top hash（大于 minTopHash）
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> top &lt; minTopHash {
					<span style="color:#c0f">throw</span>(<span style="color:#c30">&#34;bad map state&#34;</span>)
				}

				k2 <span style="color:#555">:=</span> k
				<span style="color:#09f;font-style:italic">// 如果 key 是指针，则解引用
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> t.indirectkey {
					k2 = <span style="color:#555">*</span>((<span style="color:#555">*</span>unsafe.Pointer)(k2))
				}

				<span style="color:#09f;font-style:italic">// 默认使用 X，等量扩容
</span><span style="color:#09f;font-style:italic"></span>				useX <span style="color:#555">:=</span> <span style="color:#069;font-weight:bold">true</span>
				<span style="color:#09f;font-style:italic">// 如果不是等量扩容
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> !h.<span style="color:#c0f">sameSizeGrow</span>() {
					<span style="color:#09f;font-style:italic">// 计算 hash 值，和 key 第一次写入时一样
</span><span style="color:#09f;font-style:italic"></span>					hash <span style="color:#555">:=</span> alg.<span style="color:#c0f">hash</span>(k2, <span style="color:#366">uintptr</span>(h.hash0))

					<span style="color:#09f;font-style:italic">// 如果有协程正在遍历 map
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#069;font-weight:bold">if</span> h.flags<span style="color:#555">&amp;</span>iterator <span style="color:#555">!=</span> <span style="color:#f60">0</span> {
						<span style="color:#09f;font-style:italic">// 如果出现 相同的 key 值，算出来的 hash 值不同
</span><span style="color:#09f;font-style:italic"></span>						<span style="color:#069;font-weight:bold">if</span> !t.reflexivekey <span style="color:#555">&amp;&amp;</span> !alg.<span style="color:#c0f">equal</span>(k2, k2) {
							<span style="color:#09f;font-style:italic">// 只有在 float 变量的 NaN() 情况下会出现
</span><span style="color:#09f;font-style:italic"></span>							<span style="color:#069;font-weight:bold">if</span> top<span style="color:#555">&amp;</span><span style="color:#f60">1</span> <span style="color:#555">!=</span> <span style="color:#f60">0</span> {
								<span style="color:#09f;font-style:italic">// 第 B 位置 1
</span><span style="color:#09f;font-style:italic"></span>								hash <span style="color:#555">|=</span> newbit
							} <span style="color:#069;font-weight:bold">else</span> {
								<span style="color:#09f;font-style:italic">// 第 B 位置 0
</span><span style="color:#09f;font-style:italic"></span>								hash <span style="color:#555">&amp;^=</span> newbit
							}
							<span style="color:#09f;font-style:italic">// 取高 8 位作为 top hash 值
</span><span style="color:#09f;font-style:italic"></span>							top = <span style="color:#366">uint8</span>(hash <span style="color:#555">&gt;&gt;</span> (sys.PtrSize<span style="color:#555">*</span><span style="color:#f60">8</span> <span style="color:#555">-</span> <span style="color:#f60">8</span>))
							<span style="color:#069;font-weight:bold">if</span> top &lt; minTopHash {
								top <span style="color:#555">+=</span> minTopHash
							}
						}
					}

					<span style="color:#09f;font-style:italic">// 取决于新哈希值的 oldB+1 位是 0 还是 1
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#09f;font-style:italic">// 详细看后面的文章
</span><span style="color:#09f;font-style:italic"></span>					useX = hash<span style="color:#555">&amp;</span>newbit <span style="color:#555">==</span> <span style="color:#f60">0</span>
				}

				<span style="color:#09f;font-style:italic">// 如果 key 搬到 X 部分
</span><span style="color:#09f;font-style:italic"></span>				<span style="color:#069;font-weight:bold">if</span> useX {
					<span style="color:#09f;font-style:italic">// 标志老的 cell 的 top hash 值，表示搬移到 X 部分
</span><span style="color:#09f;font-style:italic"></span>					b.tophash[i] = evacuatedX
					<span style="color:#09f;font-style:italic">// 如果 xi 等于 8，说明要溢出了
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#069;font-weight:bold">if</span> xi <span style="color:#555">==</span> bucketCnt {
						<span style="color:#09f;font-style:italic">// 新建一个 bucket
</span><span style="color:#09f;font-style:italic"></span>						newx <span style="color:#555">:=</span> h.<span style="color:#c0f">newoverflow</span>(t, x)
						x = newx
						<span style="color:#09f;font-style:italic">// xi 从 0 开始计数
</span><span style="color:#09f;font-style:italic"></span>						xi = <span style="color:#f60">0</span>
						<span style="color:#09f;font-style:italic">// xk 表示 key 要移动到的位置
</span><span style="color:#09f;font-style:italic"></span>						xk = <span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(x), dataOffset)
						<span style="color:#09f;font-style:italic">// xv 表示 value 要移动到的位置
</span><span style="color:#09f;font-style:italic"></span>						xv = <span style="color:#c0f">add</span>(xk, bucketCnt<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.keysize))
					}
					<span style="color:#09f;font-style:italic">// 设置 top hash 值
</span><span style="color:#09f;font-style:italic"></span>					x.tophash[xi] = top
					<span style="color:#09f;font-style:italic">// key 是指针
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#069;font-weight:bold">if</span> t.indirectkey {
						<span style="color:#09f;font-style:italic">// 将原 key（是指针）复制到新位置
</span><span style="color:#09f;font-style:italic"></span>						<span style="color:#555">*</span>(<span style="color:#555">*</span>unsafe.Pointer)(xk) = k2 <span style="color:#09f;font-style:italic">// copy pointer
</span><span style="color:#09f;font-style:italic"></span>					} <span style="color:#069;font-weight:bold">else</span> {
						<span style="color:#09f;font-style:italic">// 将原 key（是值）复制到新位置
</span><span style="color:#09f;font-style:italic"></span>						<span style="color:#c0f">typedmemmove</span>(t.key, xk, k) <span style="color:#09f;font-style:italic">// copy value
</span><span style="color:#09f;font-style:italic"></span>					}
					<span style="color:#09f;font-style:italic">// value 是指针，操作同 key
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#069;font-weight:bold">if</span> t.indirectvalue {
						<span style="color:#555">*</span>(<span style="color:#555">*</span>unsafe.Pointer)(xv) = <span style="color:#555">*</span>(<span style="color:#555">*</span>unsafe.Pointer)(v)
					} <span style="color:#069;font-weight:bold">else</span> {
						<span style="color:#c0f">typedmemmove</span>(t.elem, xv, v)
					}

					<span style="color:#09f;font-style:italic">// 定位到下一个 cell
</span><span style="color:#09f;font-style:italic"></span>					xi<span style="color:#555">++</span>
					xk = <span style="color:#c0f">add</span>(xk, <span style="color:#366">uintptr</span>(t.keysize))
					xv = <span style="color:#c0f">add</span>(xv, <span style="color:#366">uintptr</span>(t.valuesize))
				} <span style="color:#069;font-weight:bold">else</span> { <span style="color:#09f;font-style:italic">// key 搬到 Y 部分，操作同 X 部分
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#09f;font-style:italic">// ……
</span><span style="color:#09f;font-style:italic"></span>					<span style="color:#09f;font-style:italic">// 省略了这部分，操作和 X 部分相同
</span><span style="color:#09f;font-style:italic"></span>				}
			}
		}
		<span style="color:#09f;font-style:italic">// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> h.flags<span style="color:#555">&amp;</span>oldIterator <span style="color:#555">==</span> <span style="color:#f60">0</span> {
			b = (<span style="color:#555">*</span>bmap)(<span style="color:#c0f">add</span>(h.oldbuckets, oldbucket<span style="color:#555">*</span><span style="color:#366">uintptr</span>(t.bucketsize)))
			<span style="color:#09f;font-style:italic">// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">if</span> t.bucket.kind<span style="color:#555">&amp;</span>kindNoPointers <span style="color:#555">==</span> <span style="color:#f60">0</span> {
				<span style="color:#c0f">memclrHasPointers</span>(<span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(b), dataOffset), <span style="color:#366">uintptr</span>(t.bucketsize)<span style="color:#555">-</span>dataOffset)
			} <span style="color:#069;font-weight:bold">else</span> {
				<span style="color:#c0f">memclrNoHeapPointers</span>(<span style="color:#c0f">add</span>(unsafe.<span style="color:#c0f">Pointer</span>(b), dataOffset), <span style="color:#366">uintptr</span>(t.bucketsize)<span style="color:#555">-</span>dataOffset)
			}
		}
	}

	<span style="color:#09f;font-style:italic">// 更新搬迁进度
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// 如果此次搬迁的 bucket 等于当前进度
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> oldbucket <span style="color:#555">==</span> h.nevacuate {
		<span style="color:#09f;font-style:italic">// 进度加 1
</span><span style="color:#09f;font-style:italic"></span>		h.nevacuate = oldbucket <span style="color:#555">+</span> <span style="color:#f60">1</span>
		<span style="color:#09f;font-style:italic">// Experiments suggest that 1024 is overkill by at least an order of magnitude.
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// Put it in there as a safeguard anyway, to ensure O(1) behavior.
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#09f;font-style:italic">// 尝试往后看 1024 个 bucket
</span><span style="color:#09f;font-style:italic"></span>		stop <span style="color:#555">:=</span> h.nevacuate <span style="color:#555">+</span> <span style="color:#f60">1024</span>
		<span style="color:#069;font-weight:bold">if</span> stop &gt; newbit {
			stop = newbit
		}
		<span style="color:#09f;font-style:italic">// 寻找没有搬迁的 bucket
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">for</span> h.nevacuate <span style="color:#555">!=</span> stop <span style="color:#555">&amp;&amp;</span> <span style="color:#c0f">bucketEvacuated</span>(t, h, h.nevacuate) {
			h.nevacuate<span style="color:#555">++</span>
		}
		
		<span style="color:#09f;font-style:italic">// 现在 h.nevacuate 之前的 bucket 都被搬迁完毕
</span><span style="color:#09f;font-style:italic"></span>		
		<span style="color:#09f;font-style:italic">// 所有的 buckets 搬迁完毕
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#069;font-weight:bold">if</span> h.nevacuate <span style="color:#555">==</span> newbit {
			<span style="color:#09f;font-style:italic">// 清除老的 buckets
</span><span style="color:#09f;font-style:italic"></span>			h.oldbuckets = <span style="color:#069;font-weight:bold">nil</span>
			<span style="color:#09f;font-style:italic">// 清除老的 overflow bucket
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#09f;font-style:italic">// 回忆一下：[0] 表示当前 overflow bucket
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#09f;font-style:italic">// [1] 表示 old overflow bucket
</span><span style="color:#09f;font-style:italic"></span>			<span style="color:#069;font-weight:bold">if</span> h.extra <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
				h.extra.overflow[<span style="color:#f60">1</span>] = <span style="color:#069;font-weight:bold">nil</span>
			}
			<span style="color:#09f;font-style:italic">// 清除正在扩容的标志位
</span><span style="color:#09f;font-style:italic"></span>			h.flags <span style="color:#555">&amp;^=</span> sameSizeGrow
		}
	}
}
</code></pre></td></tr></table>
</div>
</div><p>evacuate 函数的代码注释非常清晰，对着代码和注释是很容易看懂整个的搬迁过程的，耐心点。</p>
<p>搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。</p>
<p>对于条件 2，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p>
<p>对于条件 1，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 <code>rehash</code>。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57740474-af7adb80-76ea-11e9-8409-4af0ce1a814a.png"><img src="https://user-images.githubusercontent.com/7698088/57740474-af7adb80-76ea-11e9-8409-4af0ce1a814a.png" alt="map rehash"></a>map rehash</p>
<p>因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。</p>
<p>理解了上面 bucket 序号的变化，我们就可以回答另一个问题了：为什么遍历 map 是无序的？</p>
<p>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p>
<p>当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key/value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p>
<p>当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。</p>
<p>多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p>
<p>再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。</p>
<p>例如，原始 B = 2，1号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 <code>10</code> 决定它们落在 2 号桶，现在 B 变成 3，所以 <code>010</code>、<code>110</code> 分别落入 2、6 号桶。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57818861-74df7480-77b8-11e9-8104-2a58dc006660.png"><img src="https://user-images.githubusercontent.com/7698088/57818861-74df7480-77b8-11e9-8104-2a58dc006660.png" alt="bucket split"></a>bucket split</p>
<p>理解了这个，后面讲 map 迭代的时候会用到。</p>
<p>再来讲搬迁函数中的几个关键点：</p>
<p>evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。bucket 还会链接 overflow bucket，它们同样需要搬迁。因此会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。这样的循环在 map 的源码里到处都是，要理解透了。</p>
<p>源码里提到 X, Y part，其实就是我们说的如果是扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的 key 可能会分裂落到 2 个桶，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个 Part。很简单，重新计算 cell 中 key 的 hash，并向前“多看”一位，决定落入哪个 Part，这个前面也说得很详细了。</p>
<p>有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 <code>math.NaN()</code> 的结果，它的含义是 <code>not a number</code>，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</p>
<p>你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 <code>m[math.NaN()]</code> 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 <code>math.NaN()</code> 作为 key。</p>
<p>当搬迁碰到 <code>math.NaN()</code> 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</p>
<p>这是通过 tophash 值与新算出来的哈希值进行运算得到的：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">if top&amp;1 != 0 {
    // top hash 最低位为 1
    // 新算出来的 hash 值的 B 位置 1
	hash |= newbit
} else {
    // 新算出来的 hash 值的 B 位置 0
	hash &amp;^= newbit
}

// hash 值的 B 位为 0，则搬迁到 x part
// 当 B = 5时，newbit = 32，二进制低 6 位为 10 0000
useX = hash&amp;newbit == 0
</code></pre></td></tr></table>
</div>
</div><p>其实这样的 key 我随便搬迁到哪个 bucket 都行，当然，还是要搬迁到上面裂变那张图中的两个 bucket 中去。但这样做是有好处的，在后面讲 map 迭代的时候会再详细解释，暂时知道是这样分配的就行。</p>
<p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。</p>
<p>设置 key 在原始 buckets 的 tophash 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的 x part 或是 y part。新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p>
<p>下面通过图来宏观地看一下扩容前后的变化。</p>
<p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57963483-5b286380-7957-11e9-852a-8296c6c16daa.png"><img src="https://user-images.githubusercontent.com/7698088/57963483-5b286380-7957-11e9-852a-8296c6c16daa.png" alt="扩容前"></a>扩容前</p>
<p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57963519-dc7ff600-7957-11e9-9877-36c3f4bc3526.png"><img src="https://user-images.githubusercontent.com/7698088/57963519-dc7ff600-7957-11e9-9877-36c3f4bc3526.png" alt="same size 扩容"></a>same size 扩容</p>
<p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 <code>0-3</code> 称为 x part，<code>4-7</code> 称为 y part。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57963651-04705900-795a-11e9-9801-e3dc475d4782.png"><img src="https://user-images.githubusercontent.com/7698088/57963651-04705900-795a-11e9-9801-e3dc475d4782.png" alt="2倍扩容"></a>2倍扩容</p>
<p>注意，上面的两张图忽略了其他 buckets 的搬迁情况，表示所有的 bucket 都搬迁完毕后的情形。实际上，我们知道，搬迁是一个“渐进”的过程，并不会一下子就全部搬迁完毕。所以在搬迁过程中，oldbuckets 指针还会指向原来老的 []bmap，并且已经搬迁完毕的 key 的 tophash 值会是一个状态值，表示 key 的搬迁去向。</p>
<h2 id="map-的遍历">map 的遍历</h2>
<p>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。</p>
<p>但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。</p>
<p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。</p>
<p>我先写一个简单的代码样例，假装不知道遍历过程具体调用的是什么函数：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> main

<span style="color:#069;font-weight:bold">import</span> <span style="color:#c30">&#34;fmt&#34;</span>

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
	ageMp <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">string</span>]<span style="color:#078;font-weight:bold">int</span>)
	ageMp[<span style="color:#c30">&#34;qcrao&#34;</span>] = <span style="color:#f60">18</span>

	<span style="color:#069;font-weight:bold">for</span> name, age <span style="color:#555">:=</span> <span style="color:#069;font-weight:bold">range</span> ageMp {
		fmt.<span style="color:#c0f">Println</span>(name, age)
	}
}
</code></pre></td></tr></table>
</div>
</div><p>执行命令：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">go</span> tool compile <span style="color:#555">-</span>S main.<span style="color:#069;font-weight:bold">go</span>
</code></pre></td></tr></table>
</div>
</div><p>得到汇编命令。这里就不逐行讲解了，可以去看之前的几篇文章，说得很详细。</p>
<p>关键的几行汇编代码如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-asm" data-lang="asm"><span style="color:#a00;background-color:#faa">//</span> <span style="color:#309">......</span>
<span style="color:#a00;background-color:#faa">0</span><span style="color:#c0f">x0124</span> <span style="color:#f60">00292</span> (<span style="color:#360">test16.go</span>:<span style="color:#f60">9</span>)      <span style="color:#360">CALL</span>    <span style="color:#360">runtime.mapiterinit</span>(<span style="color:#360">SB</span>)

<span style="color:#a00;background-color:#faa">//</span> <span style="color:#309">......</span>
<span style="color:#a00;background-color:#faa">0</span><span style="color:#c0f">x01fb</span> <span style="color:#f60">00507</span> (<span style="color:#360">test16.go</span>:<span style="color:#f60">9</span>)      <span style="color:#360">CALL</span>    <span style="color:#360">runtime.mapiternext</span>(<span style="color:#360">SB</span>)
<span style="color:#a00;background-color:#faa">0</span><span style="color:#c0f">x0200</span> <span style="color:#f60">00512</span> (<span style="color:#360">test16.go</span>:<span style="color:#f60">9</span>)      <span style="color:#360">MOVQ</span>    <span style="color:#a00;background-color:#faa">&#34;&#34;</span><span style="color:#360">..autotmp_4</span><span style="color:#a00;background-color:#faa">+</span><span style="color:#f60">160</span>(<span style="color:#360">SP</span>), <span style="color:#360">AX</span>
<span style="color:#a00;background-color:#faa">0</span><span style="color:#c0f">x0208</span> <span style="color:#f60">00520</span> (<span style="color:#360">test16.go</span>:<span style="color:#f60">9</span>)      <span style="color:#360">TESTQ</span>   <span style="color:#360">AX</span>, <span style="color:#360">AX</span>
<span style="color:#a00;background-color:#faa">0</span><span style="color:#c0f">x020b</span> <span style="color:#f60">00523</span> (<span style="color:#360">test16.go</span>:<span style="color:#f60">9</span>)      <span style="color:#360">JNE</span>     <span style="color:#f60">302</span>

<span style="color:#a00;background-color:#faa">//</span> <span style="color:#309">......</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，关于 map 迭代，底层的函数调用关系一目了然。先是调用 <code>mapiterinit</code> 函数初始化迭代器，然后循环调用 <code>mapiternext</code> 函数进行 map 迭代。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57976471-ad2ebf00-7a13-11e9-8dd8-d7be54f96440.png"><img src="https://user-images.githubusercontent.com/7698088/57976471-ad2ebf00-7a13-11e9-8dd8-d7be54f96440.png" alt="map iter loop"></a>map iter loop</p>
<p>迭代器的结构体定义：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> hiter <span style="color:#069;font-weight:bold">struct</span> {
	<span style="color:#09f;font-style:italic">// key 指针
</span><span style="color:#09f;font-style:italic"></span>	key         unsafe.Pointer
	<span style="color:#09f;font-style:italic">// value 指针
</span><span style="color:#09f;font-style:italic"></span>	value       unsafe.Pointer
	<span style="color:#09f;font-style:italic">// map 类型，包含如 key size 大小等
</span><span style="color:#09f;font-style:italic"></span>	t           <span style="color:#555">*</span>maptype
	<span style="color:#09f;font-style:italic">// map header
</span><span style="color:#09f;font-style:italic"></span>	h           <span style="color:#555">*</span>hmap
	<span style="color:#09f;font-style:italic">// 初始化时指向的 bucket
</span><span style="color:#09f;font-style:italic"></span>	buckets     unsafe.Pointer
	<span style="color:#09f;font-style:italic">// 当前遍历到的 bmap
</span><span style="color:#09f;font-style:italic"></span>	bptr        <span style="color:#555">*</span>bmap
	overflow    [<span style="color:#f60">2</span>]<span style="color:#555">*</span>[]<span style="color:#555">*</span>bmap
	<span style="color:#09f;font-style:italic">// 起始遍历的 bucet 编号
</span><span style="color:#09f;font-style:italic"></span>	startBucket <span style="color:#078;font-weight:bold">uintptr</span>
	<span style="color:#09f;font-style:italic">// 遍历开始时 cell 的编号（每个 bucket 中有 8 个 cell）
</span><span style="color:#09f;font-style:italic"></span>	offset      <span style="color:#078;font-weight:bold">uint8</span>
	<span style="color:#09f;font-style:italic">// 是否从头遍历了
</span><span style="color:#09f;font-style:italic"></span>	wrapped     <span style="color:#078;font-weight:bold">bool</span>
	<span style="color:#09f;font-style:italic">// B 的大小
</span><span style="color:#09f;font-style:italic"></span>	B           <span style="color:#078;font-weight:bold">uint8</span>
	<span style="color:#09f;font-style:italic">// 指示当前 cell 序号
</span><span style="color:#09f;font-style:italic"></span>	i           <span style="color:#078;font-weight:bold">uint8</span>
	<span style="color:#09f;font-style:italic">// 指向当前的 bucket
</span><span style="color:#09f;font-style:italic"></span>	bucket      <span style="color:#078;font-weight:bold">uintptr</span>
	<span style="color:#09f;font-style:italic">// 因为扩容，需要检查的 bucket
</span><span style="color:#09f;font-style:italic"></span>	checkBucket <span style="color:#078;font-weight:bold">uintptr</span>
}
</code></pre></td></tr></table>
</div>
</div><p><code>mapiterinit</code> 就是对 hiter 结构体里的字段进行初始化赋值操作。</p>
<p>前面已经提到过，即使是对一个写死的 map 进行遍历，每次出来的结果也是无序的。下面我们就可以近距离地观察他们的实现了。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// 生成随机数 r
</span><span style="color:#09f;font-style:italic"></span>r <span style="color:#555">:=</span> <span style="color:#366">uintptr</span>(<span style="color:#c0f">fastrand</span>())
<span style="color:#069;font-weight:bold">if</span> h.B &gt; <span style="color:#f60">31</span><span style="color:#555">-</span>bucketCntBits {
	r <span style="color:#555">+=</span> <span style="color:#366">uintptr</span>(<span style="color:#c0f">fastrand</span>()) <span style="color:#555">&lt;&lt;</span> <span style="color:#f60">31</span>
}

<span style="color:#09f;font-style:italic">// 从哪个 bucket 开始遍历
</span><span style="color:#09f;font-style:italic"></span>it.startBucket = r <span style="color:#555">&amp;</span> (<span style="color:#366">uintptr</span>(<span style="color:#f60">1</span>)<span style="color:#555">&lt;&lt;</span>h.B <span style="color:#555">-</span> <span style="color:#f60">1</span>)
<span style="color:#09f;font-style:italic">// 从 bucket 的哪个 cell 开始遍历
</span><span style="color:#09f;font-style:italic"></span>it.offset = <span style="color:#366">uint8</span>(r <span style="color:#555">&gt;&gt;</span> h.B <span style="color:#555">&amp;</span> (bucketCnt <span style="color:#555">-</span> <span style="color:#f60">1</span>))
</code></pre></td></tr></table>
</div>
</div><p>例如，B = 2，那 <code>uintptr(1)&lt; 结果就是 3，低 8 位为 </code>0000 0011<code>，将 r 与之相与，就可以得到一个 </code>0~3<code>的 bucket 序号；bucketCnt - 1 等于 7，低 8 位为</code>0000 0111<code>，将 r 右移 2 位后，与 7 相与，就可以得到一个 </code>0~7` 号的 cell。</p>
<p>于是，在 <code>mapiternext</code> 函数中就会从 it.startBucket 的 it.offset 号的 cell 开始遍历，取出其中的 key 和 value，直到又回到起点 bucket，完成遍历过程。</p>
<p>源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。</p>
<p>假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，<code>1 号</code>裂变成 <code>1 号</code>和 <code>3 号</code>；<code>0 号</code> bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57978113-f8a79400-7a38-11e9-8e27-3f3ba4fa557f.png"><img src="https://user-images.githubusercontent.com/7698088/57978113-f8a79400-7a38-11e9-8e27-3f3ba4fa557f.png" alt="map origin"></a>map origin</p>
<p>这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980268-a4fa7200-7a5b-11e9-9ad1-fb2b64fe3159.png"><img src="https://user-images.githubusercontent.com/7698088/57980268-a4fa7200-7a5b-11e9-9ad1-fb2b64fe3159.png" alt="map init"></a>map init</p>
<p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2。</p>
<p>因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。判断方法就是：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func evacuated(b *bmap) bool {
	h := b.tophash[0]
	return h &gt; empty &amp;&amp; h &lt; minTopHash
}
</code></pre></td></tr></table>
</div>
</div><p>如果 b.tophash[0] 的值在标志值范围内，即在 (0,4) 区间里，说明已经被搬迁过了。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go">empty = <span style="color:#f60">0</span>
evacuatedEmpty = <span style="color:#f60">1</span>
evacuatedX = <span style="color:#f60">2</span>
evacuatedY = <span style="color:#f60">3</span>
minTopHash = <span style="color:#f60">4</span>
</code></pre></td></tr></table>
</div>
</div><p>在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。</p>
<p>依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时我们的遍历结果仅有一个元素：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980302-56010c80-7a5c-11e9-8263-c11ddcec2ecc.png"><img src="https://user-images.githubusercontent.com/7698088/57980302-56010c80-7a5c-11e9-8263-c11ddcec2ecc.png" alt="iter res"></a>iter res</p>
<p>由于返回的 key 不为空，所以会继续调用 mapiternext 函数。</p>
<p>继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。</p>
<p>遍历结果集也因此壮大：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980349-2d2d4700-7a5d-11e9-819a-a59964f70a7c.png"><img src="https://user-images.githubusercontent.com/7698088/57980349-2d2d4700-7a5d-11e9-819a-a59964f70a7c.png" alt="iter res"></a>iter res</p>
<p>新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。那是不是把老 0 号 bucket 中的所有 key 都取出来呢？</p>
<p>并没有这么简单，回忆一下，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 <code>*bucket</code> 指针，也就是所谓的新 buckets）。所以，我们只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key。</p>
<p>因此，<code>lowbits == 00</code> 的将进入遍历结果集：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980449-6fa35380-7a5e-11e9-9dbf-86332ea0e215.png"><img src="https://user-images.githubusercontent.com/7698088/57980449-6fa35380-7a5e-11e9-9dbf-86332ea0e215.png" alt="iter res"></a>iter res</p>
<p>和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。结果集变成：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980487-e8a2ab00-7a5e-11e9-8e47-050437a099fc.png"><img src="https://user-images.githubusercontent.com/7698088/57980487-e8a2ab00-7a5e-11e9-8e47-050437a099fc.png" alt="iter res"></a>iter res</p>
<p>继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 <code>lowbit == 10</code> 的那些 key。</p>
<p>这样，遍历结果集变成：</p>
<p><a href="https://user-images.githubusercontent.com/7698088/57980574-ae85d900-7a5f-11e9-8050-ae314a90ee05.png"><img src="https://user-images.githubusercontent.com/7698088/57980574-ae85d900-7a5f-11e9-8050-ae314a90ee05.png" alt="iter res"></a>iter res</p>
<p>最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。</p>
<p>顺便说一下，如果碰到 key 是 <code>math.NaN()</code> 这种的，处理方式类似。核心还是要看它被分裂后具体落入哪个 bucket。只不过只用看它 top hash 的最低位。如果 top hash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。据此决定是否取出 key，放到遍历结果集里。</p>
<p>map 遍历的核心在于理解 2 倍扩容时，老 bucket 会分裂到 2 个新 bucket 中去。而遍历操作，会按照新 bucket 的序号顺序进行，碰到老 bucket 未搬迁的情况时，要在老 bucket 中找到将来要搬迁到新 bucket 来的 key。</p>
<h2 id="map-的赋值">map 的赋值</h2>
<p>通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 <code>mapassign</code> 函数。</p>
<p>实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。</p>
<p>mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。</p>
<table>
<thead>
<tr>
<th>key 类型</th>
<th>插入</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td>uint64</td>
<td>mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td>string</td>
<td>mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
</tbody>
</table>
<p>我们只用研究最一般的赋值函数 <code>mapassign</code>。</p>
<p>整体来看，流程非常得简单：对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p>
<p>源码大体和之前讲的类似，核心还是一个双层循环，外层遍历 bucket 和它的 overflow bucket，内层遍历整个 bucket 的各个 cell。限于篇幅，这部分代码的注释我也不展示了，有兴趣的可以去看，保证理解了这篇文章内容后，能够看懂。</p>
<p>我这里会针对这个过程提几点重要的。</p>
<p>函数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的。</p>
<p>通过前文我们知道扩容是渐进式的，如果 map 处在扩容的过程中，那么当 key 定位到了某个 bucket 后，需要确保这个 bucket 对应的老 bucket 完成了迁移过程。即老 bucket 里的 key 都要迁移到新的 bucket 中来（分裂到 2 个新 bucket），才能在新的 bucket 中进行插入或者更新的操作。</p>
<p>上面说的操作是在函数靠前的位置进行的，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。</p>
<p>现在到了定位 key 应该放置的位置了，所谓找准自己的位置很重要。准备两个指针，一个（<code>inserti</code>）指向 key 的 hash 值在 tophash 数组所处的位置，另一个(<code>insertk</code>)指向 cell 的位置（也就是 key 最终放置的地址），当然，对应 value 的位置就很容易定位出来了。这三者实际上都是关联的，在 tophash 数组中的索引位置决定了 key 在整个 bucket 中的位置（共 8 个 key），而 value 的位置需要“跨过” 8 个 key 的长度。</p>
<p>在循环的过程中，inserti 和 insertk 分别指向第一个找到的空闲的 cell。如果之后在 map 没有找到 key 的存在，也就是说原来 map 中没有此 key，这意味着插入新 key。那最终 key 的安置地址就是第一次发现的“空位”（tophash 是 empty）。</p>
<p>如果这个 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，发现 inserti 和 insertk 都是空，这时候需要在 bucket 后面挂上 overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。</p>
<p>在正式安置 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。</p>
<p>这之后，整个之前的查找定位 key 的过程，还得再重新走一次。因为扩容之后，key 的分布都发生了变化。</p>
<p>最后，会更新 map 相关的值，如果是插入新 key，map 的元素数量字段 count 值会加 1；在函数之初设置的 <code>hashWriting</code> 写标志出会清零。</p>
<p>另外，有一个重要的点要说一下。前面说的找到 key 的位置，进行赋值操作，实际上并不准确。我们看 <code>mapassign</code> 函数的原型就知道，函数并没有传入 value 值，所以赋值操作是什么时候执行的呢？</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer
</code></pre></td></tr></table>
</div>
</div><p>答案还得从汇编语言中寻找。我直接揭晓答案，有兴趣可以私下去研究一下。<code>mapassign</code> 函数返回的指针就是指向的 key 所对应的 value 值位置，有了地址，就很好操作赋值了。</p>
<h2 id="map-的删除">map 的删除</h2>
<p>写操作底层的执行函数是 <code>mapdelete</code>：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)
</code></pre></td></tr></table>
</div>
</div><p>根据 key 类型的不同，删除操作会被优化成更具体的函数：</p>
<table>
<thead>
<tr>
<th>key 类型</th>
<th>删除</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapdelete_fast32(t *maptype, h *hmap, key uint32)</td>
</tr>
<tr>
<td>uint64</td>
<td>mapdelete_fast64(t *maptype, h *hmap, key uint64)</td>
</tr>
<tr>
<td>string</td>
<td>mapdelete_faststr(t *maptype, h *hmap, ky string)</td>
</tr>
</tbody>
</table>
<p>当然，我们只关心 <code>mapdelete</code> 函数。它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作。</p>
<p>计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。</p>
<p>删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。</p>
<p>找到对应位置后，对 key 或者 value 进行“清零”操作：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// 对 key 清零
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">if</span> t.indirectkey {
	<span style="color:#555">*</span>(<span style="color:#555">*</span>unsafe.Pointer)(k) = <span style="color:#069;font-weight:bold">nil</span>
} <span style="color:#069;font-weight:bold">else</span> {
	<span style="color:#c0f">typedmemclr</span>(t.key, k)
}

<span style="color:#09f;font-style:italic">// 对 value 清零
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">if</span> t.indirectvalue {
	<span style="color:#555">*</span>(<span style="color:#555">*</span>unsafe.Pointer)(v) = <span style="color:#069;font-weight:bold">nil</span>
} <span style="color:#069;font-weight:bold">else</span> {
	<span style="color:#c0f">typedmemclr</span>(t.elem, v)
}
</code></pre></td></tr></table>
</div>
</div><p>最后，将 count 值减 1，将对应位置的 tophash 值置成 <code>Empty</code>。</p>
<p>这块源码同样比较简单，感兴起直接去看代码。</p>
<h1 id="map-进阶">map 进阶</h1>
<h2 id="可以边遍历边删除吗">可以边遍历边删除吗</h2>
<p>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p>
<p>一般而言，这可以通过读写锁来解决：<code>sync.RWMutex</code>。</p>
<p>读之前调用 <code>RLock()</code> 函数，读完之后调用 <code>RUnlock()</code> 函数解锁；写之前调用 <code>Lock()</code> 函数，写完之后，调用 <code>Unlock()</code> 解锁。</p>
<p>另外，<code>sync.Map</code> 是线程安全的 map，也可以使用。它的实现原理，这次先不说了。</p>
<h2 id="key-可以是-float-型吗">key 可以是 float 型吗？</h2>
<p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。这些类型的共同特征是支持 <code>==</code> 和 <code>!=</code> 操作符，<code>k1 == k2</code> 时，可认为 k1 和 k2 是同一个 key。如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key。</p>
<p>顺便说一句，任何类型都可以作为 value，包括 map 类型。</p>
<p>来看个例子：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
	m <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">float64</span>]<span style="color:#078;font-weight:bold">int</span>)
	m[<span style="color:#f60">1.4</span>] = <span style="color:#f60">1</span>
	m[<span style="color:#f60">2.4</span>] = <span style="color:#f60">2</span>
	m[math.<span style="color:#c0f">NaN</span>()] = <span style="color:#f60">3</span>
	m[math.<span style="color:#c0f">NaN</span>()] = <span style="color:#f60">3</span>

	<span style="color:#069;font-weight:bold">for</span> k, v <span style="color:#555">:=</span> <span style="color:#069;font-weight:bold">range</span> m {
		fmt.<span style="color:#c0f">Printf</span>(<span style="color:#c30">&#34;[%v, %d] &#34;</span>, k, v)
	}

	fmt.<span style="color:#c0f">Printf</span>(<span style="color:#c30">&#34;\nk: %v, v: %d\n&#34;</span>, math.<span style="color:#c0f">NaN</span>(), m[math.<span style="color:#c0f">NaN</span>()])
	fmt.<span style="color:#c0f">Printf</span>(<span style="color:#c30">&#34;k: %v, v: %d\n&#34;</span>, <span style="color:#f60">2.400000000001</span>, m[<span style="color:#f60">2.400000000001</span>])
	fmt.<span style="color:#c0f">Printf</span>(<span style="color:#c30">&#34;k: %v, v: %d\n&#34;</span>, <span style="color:#f60">2.4000000000000000000000001</span>, m[<span style="color:#f60">2.4000000000000000000000001</span>])

	fmt.<span style="color:#c0f">Println</span>(math.<span style="color:#c0f">NaN</span>() <span style="color:#555">==</span> math.<span style="color:#c0f">NaN</span>())
}
</code></pre></td></tr></table>
</div>
</div><p>程序的输出：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">[2.4, 2] [NaN, 3] [NaN, 3] [1.4, 1] 
k: NaN, v: 0
k: 2.400000000001, v: 0
k: 2.4, v: 2
false
</code></pre></td></tr></table>
</div>
</div><p>例子中定义了一个 key 类型是 float 型的 map，并向其中插入了 4 个 key：1.4， 2.4， NAN，NAN。</p>
<p>打印的时候也打印出了 4 个 key，如果你知道 NAN != NAN，也就不奇怪了。因为他们比较的结果不相等，自然，在 map 看来就是两个不同的 key 了。</p>
<p>接着，我们查询了几个 key，发现 NAN 不存在，2.400000000001 也不存在，而 2.4000000000000000000000001 却存在。</p>
<p>有点诡异，不是吗？</p>
<p>接着，我通过汇编发现了如下的事实：</p>
<p>当用 float64 作为 key 的时候，先要将其转成 unit64 类型，再插入 key 中。</p>
<p>具体是通过 <code>Float64frombits</code> 函数完成：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// Float64frombits returns the floating point number corresponding
// the IEEE 754 binary representation b.
func Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(&amp;b)) }
</code></pre></td></tr></table>
</div>
</div><p>也就是将浮点数表示成 IEEE 754 规定的格式。如赋值语句：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">0x00bd 00189 (test18.go:9)      LEAQ    &#34;&#34;.statictmp_0(SB), DX
0x00c4 00196 (test18.go:9)      MOVQ    DX, 16(SP)
0x00c9 00201 (test18.go:9)      PCDATA  $0, $2
0x00c9 00201 (test18.go:9)      CALL    runtime.mapassign(SB)
</code></pre></td></tr></table>
</div>
</div><p><code>&quot;&quot;.statictmp_0(SB)</code> 变量是这样的：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">&#34;&#34;.statictmp_0 SRODATA size=8
        0x0000 33 33 33 33 33 33 03 40
&#34;&#34;.statictmp_1 SRODATA size=8
        0x0000 ff 3b 33 33 33 33 03 40
&#34;&#34;.statictmp_2 SRODATA size=8
        0x0000 33 33 33 33 33 33 03 40
</code></pre></td></tr></table>
</div>
</div><p>我们再来输出点东西：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> main

<span style="color:#069;font-weight:bold">import</span> (
	<span style="color:#c30">&#34;fmt&#34;</span>
	<span style="color:#c30">&#34;math&#34;</span>
)

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
	m <span style="color:#555">:=</span> <span style="color:#366">make</span>(<span style="color:#069;font-weight:bold">map</span>[<span style="color:#078;font-weight:bold">float64</span>]<span style="color:#078;font-weight:bold">int</span>)
	m[<span style="color:#f60">2.4</span>] = <span style="color:#f60">2</span>

    fmt.<span style="color:#c0f">Println</span>(math.<span style="color:#c0f">Float64bits</span>(<span style="color:#f60">2.4</span>))
	fmt.<span style="color:#c0f">Println</span>(math.<span style="color:#c0f">Float64bits</span>(<span style="color:#f60">2.400000000001</span>))
	fmt.<span style="color:#c0f">Println</span>(math.<span style="color:#c0f">Float64bits</span>(<span style="color:#f60">2.4000000000000000000000001</span>))
}
<span style="color:#f60">4612586738352864255</span>
<span style="color:#f60">4612586738352862003</span>
<span style="color:#f60">4612586738352862003</span>
</code></pre></td></tr></table>
</div>
</div><p>转成十六进制为：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">0x4003333333333333
0x4003333333333BFF
0x4003333333333333
</code></pre></td></tr></table>
</div>
</div><p>和前面的 <code>&quot;&quot;.statictmp_0</code> 比较一下，很清晰了吧。<code>2.4</code> 和 <code>2.4000000000000000000000001</code> 经过 <code>math.Float64bits()</code> 函数转换后的结果是一样的。自然，二者在 map 看来，就是同一个 key 了。</p>
<p>再来看一下 NAN（not a number）：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">// NaN returns an IEEE 754 ``not-a-number&#39;&#39; value.
func NaN() float64 { return Float64frombits(uvnan) }
</code></pre></td></tr></table>
</div>
</div><p>uvan 的定义为：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">uvnan    = 0x7FF8000000000001
</code></pre></td></tr></table>
</div>
</div><p>NAN() 直接调用 <code>Float64frombits</code>，传入写死的 const 型变量 <code>0x7FF8000000000001</code>，得到 NAN 型值。既然，NAN 是从一个常量解析得来的，为什么插入 map 时，会被认为是不同的 key？</p>
<p>这是由类型的哈希函数决定的，例如，对于 64 位的浮点数，它的哈希函数如下：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">f64hash</span>(p unsafe.Pointer, h <span style="color:#078;font-weight:bold">uintptr</span>) <span style="color:#078;font-weight:bold">uintptr</span> {
	f <span style="color:#555">:=</span> <span style="color:#555">*</span>(<span style="color:#555">*</span><span style="color:#078;font-weight:bold">float64</span>)(p)
	<span style="color:#069;font-weight:bold">switch</span> {
	<span style="color:#069;font-weight:bold">case</span> f <span style="color:#555">==</span> <span style="color:#f60">0</span>:
		<span style="color:#069;font-weight:bold">return</span> c1 <span style="color:#555">*</span> (c0 ^ h) <span style="color:#09f;font-style:italic">// +0, -0
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">case</span> f <span style="color:#555">!=</span> f:
		<span style="color:#069;font-weight:bold">return</span> c1 <span style="color:#555">*</span> (c0 ^ h ^ <span style="color:#366">uintptr</span>(<span style="color:#c0f">fastrand</span>())) <span style="color:#09f;font-style:italic">// any kind of NaN
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">default</span>:
		<span style="color:#069;font-weight:bold">return</span> <span style="color:#c0f">memhash</span>(p, h, <span style="color:#f60">8</span>)
	}
}
</code></pre></td></tr></table>
</div>
</div><p>第二个 case，<code>f != f</code> 就是针对 <code>NAN</code>，这里会再加一个随机数。</p>
<p>这样，所有的谜题都解开了。</p>
<p>由于 NAN 的特性：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-fallback" data-lang="fallback">NAN != NAN
hash(NAN) != hash(NAN)
</code></pre></td></tr></table>
</div>
</div><p>因此向 map 中查找的 key 为 NAN 时，什么也查不到；如果向其中增加了 4 次 NAN，遍历会得到 4 个 NAN。</p>
<p>最后说结论：float 型可以作为 key，但是由于精度的问题，会导致一些诡异的问题，慎用之。</p>
<h1 id="总结">总结</h1>
<p>在写作本文时，有些问题看遍了中文世界的博客都没能找到解答。当然，源码可以解答任何问题。但是，你不能一下子跳进源码的细节，你得先有一个整体的认识才好。</p>
<p>所以，我开始搜索英文相关讲源码的文章，没有太多这方面的。但是我发现了一篇质量很高的文章，放在了参考资料第一条，它带领读者一步步优化，最终实现了从 map 中随机取出一个 key。推荐你去阅读，非常精彩。尤其是你知道了 map 的底层遍历、扩容的具体过程后更是如此。</p>
<p>总结一下，Go 语言中，通过哈希查找表实现 map，用链表法解决哈希冲突。</p>
<p>通过 key 的哈希值将 key 散落到不同的桶中，每个桶中有 8 个 cell。哈希值的低位决定桶序号，高位标识同一个桶中的不同 key。</p>
<p>当向桶中添加了很多 key，造成元素过多，或者溢出桶太多，就会触发扩容。扩容分为等量扩容和 2 倍容量扩容。扩容后，原来一个 bucket 中的 key 一分为二，会被重新分配到两个桶中。</p>
<p>扩容过程是渐进的，主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素，bucket 搬迁的时机则发生在赋值、删除期间，每次最多搬迁两个 bucket。</p>
<p>查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置，需要重点理解。一旦理解，关于 map 的源码就可以看懂了。</p>
<p>最后，如果文章对你有帮助，恳请你帮我分享一下，或者点一下在看，谢谢！</p>
<p>最后的最后，点击<a href="https://github.com/qcrao/Go-Questions">阅读原文</a>，你可能会参与见证一个从零开始的千星项目。</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://qcrao.com/2019/05/22/dive-into-go-map/">https://qcrao.com/2019/05/22/dive-into-go-map/</a> 精彩文章<br>
<a href="https://github.com/cch123/golang-notes/blob/master/map.md">https://github.com/cch123/golang-notes/blob/master/map.md</a> 社区大牛<br>
<a href="https://www.bilibili.com/video/BV1Q4411W7MR/?spm_id_from=333.788.videocard.7">https://www.bilibili.com/video/BV1Q4411W7MR/?spm_id_from=333.788.videocard.7</a><br>
<a href="https://blog.csdn.net/weixin_34087503/article/details/94544694">https://blog.csdn.net/weixin_34087503/article/details/94544694</a><br>
<a href="https://blog.csdn.net/m0_37579159/article/details/79344079">https://blog.csdn.net/m0_37579159/article/details/79344079</a><br>
<a href="https://blog.csdn.net/u013223806/article/details/83863103">https://blog.csdn.net/u013223806/article/details/83863103</a><br>
<a href="https://blog.csdn.net/i6448038/article/details/82057424">https://blog.csdn.net/i6448038/article/details/82057424</a><br>
<a href="https://blog.csdn.net/u010853261/article/details/99699350">https://blog.csdn.net/u010853261/article/details/99699350</a><br>
<a href="https://mp.weixin.qq.com/s/UaUJPNLURpytnbo-DnuSRw?">https://mp.weixin.qq.com/s/UaUJPNLURpytnbo-DnuSRw?</a><br>
<a href="https://blog.csdn.net/weixin_42506905/article/details/96176336">https://blog.csdn.net/weixin_42506905/article/details/96176336</a><br>
<a href="https://blog.csdn.net/Totoro19/article/details/79581430">https://blog.csdn.net/Totoro19/article/details/79581430</a></p>

                
                
                <hr> 

<div class="entry-shang text-center">
    
    <p> 「真诚赞赏，手留余香」</p>
    
    <button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
    <div class="zs-modal-head">
        <button type="button" class="close">×</button>
        <span class="author">
            <a href="http://www.mafool.com">
                <img src="http://www.mafool.com/img/reward/hollson.png" alt="史布斯" />码夫庄园
            </a>
        </span>
        
        <p class="tip"><i></i><span>嗯，我的梦想是被读者的稿费包养~</span></p>
        

    </div>
    <div class="zs-modal-body">
        <div class="zs-modal-btns">
            <button class="btn btn-blink" data-num="2">2元</button>
            <button class="btn btn-blink" data-num="5">5元</button>
            <button class="btn btn-blink" data-num="10">10元</button>
            <button class="btn btn-blink" data-num="50">50元</button>
            <button class="btn btn-blink" data-num="100">100元</button>
            <button class="btn btn-blink" data-num="1">任意金额</button>
        </div>
        <div class="zs-modal-pay">
            <button class="btn btn-bred" id="pay-text">2元</button>
            <p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
            <img src="http://www.mafool.com/img/reward/wechat-2.png" alt="史布斯" id="pay-image" />
        </div>
    </div>
    <div class="zs-modal-footer">
        <label>
            <span class="zs-wechat"></span>
            <input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked">
            <img src="http://www.mafool.com/img/reward/wechat-btn.png" alt="史布斯" />
            </span>&nbsp;
            <span>
                <input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay">
                <img src="http://www.mafool.com/img/reward/alipay-btn.png" alt="史布斯" />
            </span>
        </label>
    </div>
</div>

 

                <br>
                <br>

            </div>

        </div>
    </div>
    <div class="column is-3">
        <div class="card">
    <div class="card-content">
        <h2 class="title is-6">最近发布</h2>
        
        <h2><a class="is-size-6" href="http://www.mafool.com/posts/0742b474a643d63a774461726a6201203/">Go语言中的原子操作</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年12月2日 </time>
         
        <h2><a class="is-size-6" href="http://www.mafool.com/posts/1600330472/">Go基础笔记 - 2.3 常量</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年9月10日 </time>
         
        <h2><a class="is-size-6" href="http://www.mafool.com/posts/15996311192/">Go - Gin框架快速入门</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年9月9日 </time>
         
        <h2><a class="is-size-6" href="http://www.mafool.com/post/1597480249/">Gorm快速指南</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年8月14日 </time>
         
        <h2><a class="is-size-6" href="http://www.mafool.com/post/1597480218/">18. Go语言MySQL数据库操作</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年8月14日 </time>
         
    </div>
</div>
<br>
        




<div class="card">
  <div class="card-content">
    <h2 class="title is-6">相关文章</h2>
    
    
    <h2><a href="http://www.mafool.com/post/1586082803/">深入解读unsafe包</a></h2>
    <time class="has-text-grey-light is-size-7">5 April 2020</time>
    
    <h2><a href="http://www.mafool.com/post/1585577658/">深度解密Go语言之slice</a></h2>
    <time class="has-text-grey-light is-size-7">30 March 2020</time>
    
  </div>
</div>
<br>

        <div class="card">
    <div class="card-content">
        <h2 class="title is-6">标签</h2>
        <div>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/atomic">atomic</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/blog">blog</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/cgo">cgo</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/cloud">cloud</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/config">config</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/copy">copy</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/docker">docker</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/exam">exam</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/gin">gin</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/git">git</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/golang">golang</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/hugo">hugo</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/install">install</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/istio">istio</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/jenkins">jenkins</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/kubernetes">kubernetes</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/map">map</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/microservice">microservice</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/mycat">mycat</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/nginx">nginx</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/plan9">plan9</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/posix">posix</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/proxy">proxy</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/raft">raft</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/ssh">ssh</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/tips">tips</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/ymal">ymal</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E4%B8%BB%E4%BB%8E">主从</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E4%BA%8B%E5%8A%A1">事务</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E4%BB%A3%E7%90%86">代理</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%86%85%E5%AD%98">内存</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%8E%8B%E7%BC%A9">压缩</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%8E%9F%E5%88%9B">原创</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%8E%9F%E5%AD%90">原子</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%93%A8%E5%85%B5">哨兵</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%AD%98%E5%82%A8">存储</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%B8%B8%E9%87%8F">常量</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%B9%B6%E5%8F%91">并发</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%BC%82%E5%B8%B8">异常</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81">授权认证</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%8E%92%E5%BA%8F">排序</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%8E%A5%E5%8F%A3">接口</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%97%A5%E5%BF%97">日志</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%9D%83%E9%99%90">权限</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%A0%87%E7%AD%BE1">标签1</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%A0%87%E7%AD%BE2">标签2</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%AD%A3%E5%88%99">正则</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91">流量分发</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%B5%8B%E8%AF%95">测试</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E6%BA%90%E7%A0%81">源码</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E7%AE%97%E6%B3%95">算法</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">编程模式</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E8%80%81%E5%A6%96%E7%AC%94%E8%AE%B0">老妖笔记</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%80%83%E9%80%B8">逃逸</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%85%8D%E7%BD%AE">配置</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%87%8D%E5%86%99">重写</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%9B%86%E7%BE%A4">集群</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="http://www.mafool.com/tags/%E9%9D%A2%E8%AF%95">面试</a>
            </span>
            
        </div>
    </div>
</div>
<br>
    </div>
</div>

        </div>
    </div>

    
    <footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <span class="icon is-large">
                <a href="https://twitter.com/" class="mysocial" rel="me">
                    <i class="fab fa-twitter fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <span class="icon is-large">
                <a href="https://www.youtube.com/" class="mysocial" rel="me">
                    <i class="fab fa-youtube fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <span class="icon is-large">
                <a href="https://github.com/" class="mysocial" rel="me">
                    <i class="fab fa-github fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <br><br>
            友情链接：
            
            <a class="mysocial" href="http://www.mafool.com" target="_blank">Mafool</a>
            
            <a class="mysocial" href="https://gohugo.io/documentation/" target="_blank">Hugo</a>
            
            <a class="mysocial" href="https://bulma.io/" target="_blank">Bulma</a>
            
            <a class="mysocial" href="https://bootstrapious.com/" target="_blank">Bootstrapious</a>
            
            <a class="mysocial" href="https://youzhixueyuan.com/" target="_blank">Youzhixueyuan</a>
            
            <br><br />
            版权所有 &copy; 码夫庄园 2021
            - <a class="mysocial" href="https://github.com/hollson/hugo-theme-dooz">Hugo Theme</a>
        </p>
    </div>
</footer>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='http://www.mafool.com/js/dooz.totop.js?v=0.0.0' async=""></script>


<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = 'https://hm.baidu.com/hm.js?f185359ec6b829a6a93e1e1f2597f6d9';
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-DK042XSJ2J"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-DK042XSJ2J');
</script>

    
    
<script type="text/javascript" src="http://www.mafool.com/js/reward.js"></script>

    
    <script defer src="https://cdn.staticfile.org/font-awesome/5.13.0/js/all.min.js"></script>
</body>

</html>