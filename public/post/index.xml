<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 码夫庄园</title>
    <link>http://www.mafool.com/post/</link>
    <description>Recent content in Posts on 码夫庄园</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>版权所有</copyright>
    <lastBuildDate>Wed, 02 Dec 2020 22:03:06 +0800</lastBuildDate>
    
        <atom:link href="http://www.mafool.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go语言中的原子操作</title>
      <link>http://www.mafool.com/posts/0742b474a643d63a774461726a6201203/</link>
      <pubDate>Wed, 02 Dec 2020 22:03:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/0742b474a643d63a774461726a6201203/</guid>
      <description>原子操作 原子操作中，针对某个值的操作，CPU不会再去进行其他的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子</description>
    </item>
    
    <item>
      <title>Go基础笔记 - 2.3 常量</title>
      <link>http://www.mafool.com/posts/1600330472/</link>
      <pubDate>Thu, 10 Sep 2020 21:36:02 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/1600330472/</guid>
      <description>[TOC] 一. 关于常量 常量有：显示常量、隐式常量、全局常量、局部常量、编译时常量。 常量只能是布尔型，数字型(整型，浮点型和复数)和字符串类型。 常量是</description>
    </item>
    
    <item>
      <title>Go - Gin框架快速入门</title>
      <link>http://www.mafool.com/posts/15996311192/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/posts/15996311192/</guid>
      <description>[TOC] 一. 路由 单路由 分组路由 自定义路由 二. 请求 Query参数 Body参数 Method 方法 安全性 说明 GET 安全、幂等 用于获取资源 HEAD 安全、幂等 只返回头部信息 POST 非安</description>
    </item>
    
    <item>
      <title>17. Go语言database/sql接口</title>
      <link>http://www.mafool.com/post/1597480217/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1597480217/</guid>
      <description>[TOC] 一、database/sql接口 Go语言官方没有提供数据库驱动，而是为开发数据库驱动定义了标准数据库驱动接口database/sql，开发</description>
    </item>
    
    <item>
      <title>18. Go语言MySQL数据库操作</title>
      <link>http://www.mafool.com/post/1597480218/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1597480218/</guid>
      <description>[TOC] 一、MySQL安装驱动 Go官方没有提供数据库驱动，最常用的开源MySQL数据库驱动非Go-MySQL-Driver莫属: 维护比较好。 完全支</description>
    </item>
    
    <item>
      <title>Gorm快速指南</title>
      <link>http://www.mafool.com/post/1597480249/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1597480249/</guid>
      <description>[TOC] Gorm介绍 Github Gorm是一个使用Go语言编写的ORM框架。中文官方网站内含十分齐全的中文文档 ，对开发者友好，支持主流数据库。 安装Gorm：</description>
    </item>
    
    <item>
      <title>Option编程模式</title>
      <link>http://www.mafool.com/posts/848cd59ca42c13602cf7b0ddf6ca1d1f/</link>
      <pubDate>Thu, 09 Jul 2020 21:34:07 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/848cd59ca42c13602cf7b0ddf6ca1d1f/</guid>
      <description>什么是Option模式 Option模式的专业术语为：Functional Options Pattern（函数式选项模式） Option模式为golang的开</description>
    </item>
    
    <item>
      <title>PostgreSQL&#43;Pgpool实现HA主备切换</title>
      <link>http://www.mafool.com/posts/4a08ebfa30e31cfbc6f0e1305fb21fdb/</link>
      <pubDate>Mon, 06 Jul 2020 17:32:52 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/4a08ebfa30e31cfbc6f0e1305fb21fdb/</guid>
      <description></description>
    </item>
    
    <item>
      <title>安装Postgresql数据库</title>
      <link>http://www.mafool.com/posts/postgresql-install/</link>
      <pubDate>Mon, 06 Jul 2020 16:35:12 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/postgresql-install/</guid>
      <description>1. Yum安装 参考官方安装向导 。 1 2 3 4 5 6 7 8 9 10 11 12 13 # 安装服务(CENTOS7) yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm yum install -y postgresql96-server /usr/pgsql-9.6/bin/postgresql96-setup initdb systemctl enable postgresql-9.6 systemctl start postgresql-9.6 #查看服务 psql --version ps -ef|grep postgres # 卸</description>
    </item>
    
    <item>
      <title>Git入门</title>
      <link>http://www.mafool.com/posts/36c29462cec19ee3cad6610506ea56dd/</link>
      <pubDate>Thu, 21 May 2020 11:28:22 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/36c29462cec19ee3cad6610506ea56dd/</guid>
      <description>https://oscimg.oschina.net/oscnet/99c82f109b10b170870caff0690c69d2588.jpg Git 仓库 1.1Git 基本概念 ​ 在Git中，我们将需要进行版本控制的文件目录叫做一个仓库（repository），每个仓库可以简单理解成一个目录，这个目</description>
    </item>
    
    <item>
      <title>Go基础笔记 - 2.2 作用域</title>
      <link>http://www.mafool.com/posts/1600334132/</link>
      <pubDate>Sun, 10 May 2020 21:36:02 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/1600334132/</guid>
      <description>[TOC] 变量作用域 Golang有四个作用域：全局作用域、函数作用域、语句作用域和块内作用域。 1 2 3 4 5 6 7 8 9 var a string = &amp;#34;hello&amp;#34; //1.全局作用域（字符串</description>
    </item>
    
    <item>
      <title>Jenkins- 构建Go项目</title>
      <link>http://www.mafool.com/posts/199ea5b7cf7372f8ce9886fdbd3d6aae/</link>
      <pubDate>Tue, 21 Apr 2020 01:44:07 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/199ea5b7cf7372f8ce9886fdbd3d6aae/</guid>
      <description>前言 Jenkins是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等</description>
    </item>
    
    <item>
      <title>Go - 内存分配原理</title>
      <link>http://www.mafool.com/posts/4f1b039fa5fd1a09e83a47bfac1fef0f/</link>
      <pubDate>Tue, 14 Apr 2020 16:53:27 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/4f1b039fa5fd1a09e83a47bfac1fef0f/</guid>
      <description>深入理解GO语言之内存详解 一. 前言 Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的</description>
    </item>
    
    <item>
      <title>Go - 实现布隆过滤器</title>
      <link>http://www.mafool.com/posts/6f1ada1f5080f30710343b9d9c36592f/</link>
      <pubDate>Mon, 13 Apr 2020 00:49:27 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/6f1ada1f5080f30710343b9d9c36592f/</guid>
      <description>1. 概念 布隆过滤器（Bloom Filter） 是由 Howard Bloom在1970年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元</description>
    </item>
    
    <item>
      <title>Linux - 四种IO模型简介</title>
      <link>http://www.mafool.com/posts/4a72f077ca65b5f3952d202fa0edf421/</link>
      <pubDate>Sat, 11 Apr 2020 17:22:24 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/4a72f077ca65b5f3952d202fa0edf421/</guid>
      <description>IO模型 服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种： 同步阻塞IO（Blocking IO）：即传统的IO模型。 同步非阻塞I</description>
    </item>
    
    <item>
      <title>POSIX - 可移植操作系统接口</title>
      <link>http://www.mafool.com/posts/518ce644178d75ca09829c29bee8341b/</link>
      <pubDate>Sat, 11 Apr 2020 12:09:16 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/518ce644178d75ca09829c29bee8341b/</guid>
      <description>什么是POSIX POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提</description>
    </item>
    
    <item>
      <title>字典树详解与实现</title>
      <link>http://www.mafool.com/posts/0aa0b471cae5bf3523c8de46d7f37c60/</link>
      <pubDate>Fri, 10 Apr 2020 23:12:20 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/0aa0b471cae5bf3523c8de46d7f37c60/</guid>
      <description>前言 在计算机科学中，trie又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点</description>
    </item>
    
    <item>
      <title>「转」Go并发之优雅退出</title>
      <link>http://www.mafool.com/posts/0742b474a643d63a774461726a6d328c/</link>
      <pubDate>Fri, 10 Apr 2020 22:03:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/0742b474a643d63a774461726a6d328c/</guid>
      <description>前言 goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能</description>
    </item>
    
    <item>
      <title>Docker之Dockerfile详解</title>
      <link>http://www.mafool.com/posts/97029d3d3c08b182359e59ed692f17a4/</link>
      <pubDate>Thu, 09 Apr 2020 00:26:35 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/97029d3d3c08b182359e59ed692f17a4/</guid>
      <description>一. 基础命令： 1. FROM：基础镜像 1 2 3 4 5 6 # 注释部分 FROM ubuntu:14.04 MAINTAINER Hollson &amp;#34;hollson@qq.com&amp;#34; RUN apt-get update RUN apt-get install -y nginx EXPOSE 80 2. MAINTAINER：作者信息 1 MAINTAINER Hollson &amp;#34;hollson@qq.com&amp;#34; 3. RUN：指定</description>
    </item>
    
    <item>
      <title>分布式系统概述</title>
      <link>http://www.mafool.com/posts/d40cede24573717edfd927aad8bb5042/</link>
      <pubDate>Wed, 08 Apr 2020 22:26:52 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/d40cede24573717edfd927aad8bb5042/</guid>
      <description>前言 说起分布式系统，我们就不得不说下分布式系统的祖先——集中式系统。集中式系统跟分布式系统是完全相反的两个概念。集中式系统就是把所有的程序、</description>
    </item>
    
    <item>
      <title>深入解读unsafe包</title>
      <link>http://www.mafool.com/post/1586082803/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1586082803/</guid>
      <description>一. 关于 unsafe 包 Unsafe 包主要用于指针计算和指针类型转换(具体可以查阅unsafe 源码或unsafe 文档）。unsafe 包源码如下： 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>Go中的正则表达式</title>
      <link>http://www.mafool.com/post/1585727755/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585727755/</guid>
      <description>一. 正则规范 Go正则表达式语法与Perl、Python等语言一样，都采用了RE2语法规范。RE2的目标是能够处理来自不受信任用户的正则表达式</description>
    </item>
    
    <item>
      <title>Mysql的乐观锁与悲观锁</title>
      <link>http://www.mafool.com/post/1585752015/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585752015/</guid>
      <description>一. 悲观锁(PCC) 悲观锁概念 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）</description>
    </item>
    
    <item>
      <title>「转」服务器雪崩的场景与解决方案</title>
      <link>http://www.mafool.com/post/1585745291/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585745291/</guid>
      <description>什么是应用服务雪崩 雪崩问题 分布式系统都存在这样一个问题，由于网络的不稳定性，决定了任何一个服务的可用性都不是 100% 的。当网络不稳定的时候，作为服</description>
    </item>
    
    <item>
      <title>Go语言之细节决定成败</title>
      <link>http://www.mafool.com/post/1585588756/</link>
      <pubDate>Tue, 31 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585588756/</guid>
      <description>[TOC] 1.变量 全局变量不能使用类型推导 2.常量 常量属于硬编码(即当作指令数据)，所以不能取地址 1 2 3 4 const a = 100 func main() { fmt.Println(&amp;amp;a,a) } 1 2 3 4 5 6 7 8 9 10 11 const</description>
    </item>
    
    <item>
      <title>Istio入门系列-Istio介绍</title>
      <link>http://www.mafool.com/post/1585546631/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585546631/</guid>
      <description>istio 简介 官网教程。 istio 相关文章列表： istio 简介 istio 性能测试 istio 是什么 Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等</description>
    </item>
    
    <item>
      <title>Nginx实现301重定向</title>
      <link>http://www.mafool.com/post/1585501895/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585501895/</guid>
      <description>前言 在企业网站运维的过程中，如果遇到以下等情况，网站就需要做URL重定向了： 网站有www.ABC.com和ABC.com域名，为了SEO优化</description>
    </item>
    
    <item>
      <title>深度解密Go语言之map</title>
      <link>http://www.mafool.com/post/1585573653/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585573653/</guid>
      <description>前言 Hash table 是计算机数据结构中一个最重要的设计。大部分hash table都实现了快速查找、添加、删除的功能，Go 语言内置的 map 实现了上述所有功能。</description>
    </item>
    
    <item>
      <title>深度解密Go语言之slice</title>
      <link>http://www.mafool.com/post/1585577658/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585577658/</guid>
      <description>源码 1 open -a goland $GOROOT/src/runtime/slice.go 源码简读 原型 1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } make操作 经常被问到new和make读区别，来看一看到底干来啥 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>Linux Bash终端设置代理访问</title>
      <link>http://www.mafool.com/posts/1585335064/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/1585335064/</guid>
      <description>Linux bash终端设置代理（proxy）访问 Linux是开源操作系统，有很多软件包需要从国外网站上下载，而其中大部分国外网站是被墙的，这时我们需</description>
    </item>
    
    <item>
      <title>Hugo创建站内搜索引擎</title>
      <link>http://www.mafool.com/2020/03/hugo%E5%88%9B%E5%BB%BA%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/2020/03/hugo%E5%88%9B%E5%BB%BA%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</guid>
      <description>目标是建立静态站点搜索： 无需在计算机上安装任何JS模块 不索引停用词，即“和，或与……”之类的词 逐页索引单词（无重复） 您下一个创建的页面将自动</description>
    </item>
    
    <item>
      <title>使用Hugo搭建静态博客</title>
      <link>http://www.mafool.com/2020/03/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/2020/03/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</guid>
      <description>Hugo介绍 Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 安装Hugo 1 2 3 4 5 6 # Mac安装 $ brew install hugo # 查看</description>
    </item>
    
    <item>
      <title>用Go实现一个数学表达式计算引擎</title>
      <link>http://www.mafool.com/2020/03/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/2020/03/%E7%94%A8go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E/</guid>
      <description>用Go实现一个数学表达式计算引擎 deng-dev 发布在 10个月前 更新于 4个月前 算法计算引擎ASTGo math-engine-demo 导读 这篇文章将从头开始，使用 Go 语言来实现一个完整的数</description>
    </item>
    
    <item>
      <title>Go之Logrus日志框架</title>
      <link>http://www.mafool.com/2020/03/go%E4%B9%8Blogrus%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2020/03/go%E4%B9%8Blogrus%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</guid>
      <description>logrus介绍 golang标准库的日志框架非常简单，仅仅提供了print，panic和fatal三个函数。对于更精细的日志级别、日志文件分</description>
    </item>
    
    <item>
      <title>Go之命令行工具教程</title>
      <link>http://www.mafool.com/2020/03/go%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2020/03/go%E4%B9%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/</guid>
      <description>[TOC] 一. 命令行预览 Go命令行使用二级命令，格式go &amp;lt;command&amp;gt; [arguments] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44</description>
    </item>
    
    <item>
      <title>Etcd - 搭建伪集群</title>
      <link>http://www.mafool.com/posts/aff3b81a3477dddf3a0e9115dd348b11/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/posts/aff3b81a3477dddf3a0e9115dd348b11/</guid>
      <description>一. ETCD简介 Etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。</description>
    </item>
    
    <item>
      <title>sync.errgroup 源码解读</title>
      <link>http://www.mafool.com/posts/f0e1186f6b7f094003d14539f38425d6/</link>
      <pubDate>Sun, 08 Mar 2020 21:38:42 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/f0e1186f6b7f094003d14539f38425d6/</guid>
      <description>前言 在启动多个Go协程并发的时候，处理子协程的异常是一件麻烦的事，你可能得需要通过多个类似&amp;lt;-error.New(...)向main协</description>
    </item>
    
    <item>
      <title>Go之接口解读</title>
      <link>http://www.mafool.com/posts/09f6faa09d79344eba8fcef184997d68/</link>
      <pubDate>Sat, 07 Mar 2020 23:26:48 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/09f6faa09d79344eba8fcef184997d68/</guid>
      <description>1.2 接口 Go 语言中的接口就是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们更好地组织并写出易于测试的代码，然而很多工程师对 Go 的接口</description>
    </item>
    
    <item>
      <title>CSS框架Bulma教程</title>
      <link>http://www.mafool.com/2020/02/css%E6%A1%86%E6%9E%B6bulma%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2020/02/css%E6%A1%86%E6%9E%B6bulma%E6%95%99%E7%A8%8B/</guid>
      <description>Bulma是一个比Bootstrap 更轻量化、更易用的CSS框架。有了它，即使完全不懂 CSS，也可以轻而易举做出美观的网页。 一、简介 Bulm</description>
    </item>
    
    <item>
      <title>「转」图解go反射实现原理</title>
      <link>http://www.mafool.com/posts/1f880505b15bc9af30837c3286fdd2c5/</link>
      <pubDate>Mon, 17 Feb 2020 01:38:43 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/1f880505b15bc9af30837c3286fdd2c5/</guid>
      <description>https://i6448038.github.io/tags/golang/) Go反射的实现和interface和unsafe.Pointer密切相关。如果对golang的interface底层实现还没有理解，可以去</description>
    </item>
    
    <item>
      <title>Kafka环境部署</title>
      <link>http://www.mafool.com/post/1585728530/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585728530/</guid>
      <description>一. 搭建Zookeeper 参考Zookeeper安装教程 1 2 3 $ jps 1699 QuorumPeerMain # zookeeper进程 1702 Jps 二. 搭建单机Kafka 1. 下载Kafka： 参</description>
    </item>
    
    <item>
      <title>Redis为什么这么快</title>
      <link>http://www.mafool.com/posts/ce39f185a4105efee0e4d06d943f2d28/</link>
      <pubDate>Sat, 11 Jan 2020 00:29:11 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/ce39f185a4105efee0e4d06d943f2d28/</guid>
      <description>当然，将数据存储在内存中，读取的时候不需要进行磁盘的 IO，单线程也保证了系统没有线程的上下文切换。 但这两点只是 Redis 高性能原因的很小一部分，下面</description>
    </item>
    
    <item>
      <title>Go操作Zookeeper</title>
      <link>http://www.mafool.com/post/1585819046/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585819046/</guid>
      <description>一. ZK集群连接对象 可以使用zk.WithXXX函数创建私有Option闭包对象，，然后以回调函数的方式传递(注入)给ZK连接方法。 With</description>
    </item>
    
    <item>
      <title>JWT实现认证授权</title>
      <link>http://www.mafool.com/post/1585829952/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585829952/</guid>
      <description>一. JWT是什么 JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。简单说，OAuth 就是一种授权机制, 数据的所有者告诉系统，同意授</description>
    </item>
    
    <item>
      <title>Go并发1-并发模型</title>
      <link>http://www.mafool.com/post/1585677184/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585677184/</guid>
      <description>[TOC] 一. 并发概念 1. 多核CPU 单核CPU主频接近4GHz时遇到瓶颈(能耗和散热),所以2005年4月Intel推出第一次双核奔腾CPU。 多核CP</description>
    </item>
    
    <item>
      <title>Go并发2-同步编程</title>
      <link>http://www.mafool.com/post/1585677428/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585677428/</guid>
      <description>[TOC] Sync包简述： Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library &amp;gt; routines. Higher-level synchronization is better done via channels and communication. Values containing the types defined in this package should not be copied. Sync包同步提供基本的</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.1 快速入门</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch201/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch201/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.1 快速入门 本节我们将通过一系列由浅入深的小例子来快速掌握CGO的基本用法。 2.1.1 最简CGO程</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.10 编译和链接参数</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch210/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch210/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.10 编译和链接参数 编译和链接参数是每一个C/C++程序员需要经常面对的问题。构建每一个C/</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.2 CGO基础</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch202/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch202/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.2 CGO基础 要使用CGO特性，需要安装C/C++构建工具链，在macOS和Linux下是</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.3 类型转换</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch203/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch203/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.3 类型转换 最初CGO是为了达到方便从Go语言函数调用C语言函数（用C语言实现Go语言声明</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.4 函数调用</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch204/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch204/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.4 函数调用 函数是C语言编程的核心，通过CGO技术我们不仅仅可以在Go语言中调用C语言函数</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.5 内部机制</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch205/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch205/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.5 内部机制 对于刚刚接触CGO用户来说，CGO的很多特性类似魔法。CGO特性主要是通过一个</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.6 实战: 封装qsort</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch206/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch206/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.6 实战: 封装qsort qsort快速排序函数是C语言的高阶函数，支持用于自定义排序比较函</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.7 CGO内存模型</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch207/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch207/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.7 CGO内存模型 CGO是架接Go语言和C语言的桥梁，它使二者在二进制接口层面实现了互通，</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.8 C&#43;&#43; 类包装</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch208/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch208/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.8 C++ 类包装 CGO是C语言和Go语言之间的桥梁，原则上无法直接支持C++的类。CGO不支持</description>
    </item>
    
    <item>
      <title>Cgo编程笔记 - 2.9 静态库和动态库</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch209/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch209/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 2.9 静态库和动态库 CGO在使用C/C++资源的时候一般有三种形式：直接使用源码；链接静态库</description>
    </item>
    
    <item>
      <title>Go分布式笔记 - 6.1 编译和链接参数</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch601/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch601/</guid>
      <description>本文为Go学习笔记，感谢《Go语言高级编程》开源图书 6.1 分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复</description>
    </item>
    
    <item>
      <title>Go汇编笔记 - 3.1 汇编入门</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch301/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch301/</guid>
      <description>Go汇编程序 Go汇编程序无法独立使用,必须以Go包的方式组织;且至少要有一个Go文件指明当前包名等基本包信息；如果Go汇编代码中的变量和函数</description>
    </item>
    
    <item>
      <title>Go汇编笔记 - 3.2 计算机结构</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch302/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch302/</guid>
      <description>3.2 计算机结构 汇编语言是直面计算机的编程语言，因此理解计算机结构是掌握汇编语言的前提。当前流行的计算机基本采用的是冯·诺伊曼计算机体系结构（在</description>
    </item>
    
    <item>
      <title>Go汇编笔记 - 3.4 函数</title>
      <link>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch304/</link>
      <pubDate>Mon, 16 Dec 2019 18:17:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/c6f2df1d75efd06ab8cd9809a60975a4ch304/</guid>
      <description>3.4 函数 终于到函数了！因为Go汇编语言中，可以也建议通过Go语言来定义全局变量，那么剩下的也就是函数了。只有掌握了汇编函数的基本用法，才能真正</description>
    </item>
    
    <item>
      <title>Git - 搭建Gitlab</title>
      <link>http://www.mafool.com/posts/ac0ed12649b48c40b6bdaa9e07f11039/</link>
      <pubDate>Thu, 12 Dec 2019 00:29:18 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/ac0ed12649b48c40b6bdaa9e07f11039/</guid>
      <description>Gitlab官网： https://about.gitlab.com/ Docker镜像： https://hub.docker.com/_/gitlab-community-edition 1. 创建GitLab目录 为了数据的操作安全，建议创建data、config、logs三个数据卷。 1 $ mkdir</description>
    </item>
    
    <item>
      <title>CAP定理和分布式数据库管理系统</title>
      <link>http://www.mafool.com/post/1585838490/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585838490/</guid>
      <description>过去，当我们想存储更多数据或提高处理能力时，通常的选择是垂直扩展（获得功能更强大的计算机）或进一步优化现有代码库。但是，随着并行处理和分布式</description>
    </item>
    
    <item>
      <title>Redis哨兵模式和集群搭建</title>
      <link>http://www.mafool.com/post/1585749845/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585749845/</guid>
      <description>参考链接 https://zhangweisep.github.io/2018/09/26/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/ https://segmentfault.com/a/1190000021622469 https://phachon.com/redis/redis-2.html http://objcoding.com/2019/01/17/redis-sentinel/ http://www.throwable.club/2019/10/07/redis-server-sentinel-install-guide/</description>
    </item>
    
    <item>
      <title>Go并发3-Channel进程通信</title>
      <link>http://www.mafool.com/post/1585855719/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585855719/</guid>
      <description>不同于传统的多线程并发模型使用共享内存来实现线程间通信的方式，golang 的哲学是通过 channel 进行协程(goroutine)之间的通信来实现数据共</description>
    </item>
    
    <item>
      <title>Go并发4-Context</title>
      <link>http://www.mafool.com/post/1585856050/</link>
      <pubDate>Mon, 07 Oct 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585856050/</guid>
      <description>关于Context： 在WebServer中，每个请求都对应一个goroutine，同时还会启动若干goroutine去处理后端业务，如数据库</description>
    </item>
    
    <item>
      <title>「转」MySQL慢查询优化、索引优化、以及表等优化总结</title>
      <link>http://www.mafool.com/post/1585905443/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585905443/</guid>
      <description>MySQL优化概述 MySQL数据库常见的两个瓶颈是：CPU和I/O的瓶颈。 CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。 磁</description>
    </item>
    
    <item>
      <title>Docker搭建Harbor私有仓库</title>
      <link>http://www.mafool.com/post/1585679557/</link>
      <pubDate>Sun, 08 Sep 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585679557/</guid>
      <description>前言 Harbor是由VMware公司开源的企业级的Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理</description>
    </item>
    
    <item>
      <title>Go Mod依赖管理</title>
      <link>http://www.mafool.com/post/1585676161/</link>
      <pubDate>Wed, 14 Aug 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585676161/</guid>
      <description>一. 发展历史 GOPATH时代：所有代码都放到GOPATH下，对于没有任何外部依赖管理（淘汰） Vendor时代：vendor目录下的包会被优先</description>
    </item>
    
    <item>
      <title>「转」Go之优雅代码之道</title>
      <link>http://www.mafool.com/posts/d780d847caf0f29efb743f0ae0c8d2aa/</link>
      <pubDate>Wed, 07 Aug 2019 23:21:42 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/d780d847caf0f29efb743f0ae0c8d2aa/</guid>
      <description>[TOC] 如何写出优雅的 Go 语言代码 2019-05-30GolangGo代码规范单元测试最佳实践接口 Go 语言是一门简单、易学的编程语言，对于有编程背景的</description>
    </item>
    
    <item>
      <title>十大经典排序01 - 冒泡排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F01-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们</description>
    </item>
    
    <item>
      <title>十大经典排序02 - 选择排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F02-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F02-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是</description>
    </item>
    
    <item>
      <title>十大经典排序03 - 插入排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F03-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F03-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入</description>
    </item>
    
    <item>
      <title>十大经典排序04 - 希尔排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F04-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F04-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而</description>
    </item>
    
    <item>
      <title>十大经典排序05 - 归并排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F05-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典</description>
    </item>
    
    <item>
      <title>十大经典排序06 - 快速排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F06-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F06-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，</description>
    </item>
    
    <item>
      <title>十大经典排序07 - 堆排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F07-%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F07-%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点</description>
    </item>
    
    <item>
      <title>十大经典排序08 - 计数排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F08-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F08-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定</description>
    </item>
    
    <item>
      <title>十大经典排序09 - 桶排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F09-%E6%A1%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F09-%E6%A1%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</description>
    </item>
    
    <item>
      <title>十大经典排序10 - 基数排序</title>
      <link>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2019/07/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>算法介绍 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字</description>
    </item>
    
    <item>
      <title>Mysql分表分库1 - Mycat安装与配置</title>
      <link>http://www.mafool.com/post/1585906994/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585906994/</guid>
      <description>一. Mycat安装 Mycat是一款数据库分库分表中间件。 1. 安装依赖项 安装JDK1.7+ 安装Mysql(略), 建议安装mysql8.0以下版本</description>
    </item>
    
    <item>
      <title>Mysql分表分库2 - Mycat实战演练</title>
      <link>http://www.mafool.com/post/1585907144/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585907144/</guid>
      <description>一. 配置规则 1. 分片方式 分片 连续分片 离散分片 优点 扩容无需迁移数据范围条件查询消耗资源少 并发访问能力增强范围条件查询性能提升 缺点 存在数据热点的可</description>
    </item>
    
    <item>
      <title>分布式理论(一) - CAP定理</title>
      <link>http://www.mafool.com/post/1585839366/</link>
      <pubDate>Sat, 06 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585839366/</guid>
      <description>前言 CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partiti</description>
    </item>
    
    <item>
      <title>分布式理论(二) - BASE理论</title>
      <link>http://www.mafool.com/post/1585838938/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585838938/</guid>
      <description>前言 BASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于C</description>
    </item>
    
    <item>
      <title>分布式理论(三) - 2PC协议</title>
      <link>http://www.mafool.com/post/1585839040/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585839040/</guid>
      <description>前言 由于BASE理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法和协议。其中比较著名的有二阶提交协议（2 Phase Commitment Protoc</description>
    </item>
    
    <item>
      <title>分布式理论(四) - 3PC协议</title>
      <link>http://www.mafool.com/post/1585839114/</link>
      <pubDate>Wed, 03 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585839114/</guid>
      <description>分布式理论(四) - 3PC协议 前言 由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷。所以，研究者们在二阶段提交的基础上做了改进，提出了三</description>
    </item>
    
    <item>
      <title>分布式理论(五) 一致性算法Paxos</title>
      <link>http://www.mafool.com/post/1585839221/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585839221/</guid>
      <description>前言 世界上只有一种一致性算法，就是 Paxos。出自一位 Google 大神之口。Paxos 也是出名的 晦涩难懂，推理过程极其复杂。 Paxos 有点类似之前说的 2PC，</description>
    </item>
    
    <item>
      <title>分布式理论(六) - 一致性协议Raft</title>
      <link>http://www.mafool.com/post/1585839270/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585839270/</guid>
      <description>分布式理论(六) - 一致性协议Raft 前言 Raft 也是一个 一致性算法，和 Paxos 目标相同。但它还有另一个名字 - 易于理解的一致性算法。Paxos 和 Raft 都是为了</description>
    </item>
    
    <item>
      <title>Kafka面试自测系列1</title>
      <link>http://www.mafool.com/post/1585721646/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585721646/</guid>
      <description>面试题，不仅是面试指南，更是自我知识检测手段 1.什么是kafka Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，</description>
    </item>
    
    <item>
      <title>Kafka面试自测系列2</title>
      <link>http://www.mafool.com/post/1585721666/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585721666/</guid>
      <description>面试题，不仅是面试指南，更是自我知识检测手段 1.Kafka 的设计时什么样的呢？ Kafka 将消息以 topic 为单位进行归纳 将向 Kafka topic 发布消息的程序成为 producers. 将预订 topics 并消费消息的</description>
    </item>
    
    <item>
      <title>Kafka面试自测系列3</title>
      <link>http://www.mafool.com/post/1585721669/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585721669/</guid>
      <description>面试题，不仅是面试指南，更是自我知识检测手段 问题1：什么是Apache Kafka? 答：Apache Kafka是一个发布 - 订阅开源消息代理应用程序。这个</description>
    </item>
    
    <item>
      <title>Nginx自测 - 课后练习题</title>
      <link>http://www.mafool.com/post/1585725105/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585725105/</guid>
      <description>1、什么是Nginx? Nginx是一款开源的、高性能的HTTP服务器、反向代理服务器和邮件代理服务器,具有负载均衡器和HTTP缓存的能力。 N</description>
    </item>
    
    <item>
      <title>Nginx面试自测系列3</title>
      <link>http://www.mafool.com/post/1585725111/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585725111/</guid>
      <description>Nginx有哪些功能 http代理和反向代理、负载均衡、web缓存。 1、负载均衡主要有轮询、加权轮询和IP Hash三种策略，扩展策略主要是通过</description>
    </item>
    
    <item>
      <title>Redis面试汇总</title>
      <link>http://www.mafool.com/post/1585724939/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585724939/</guid>
      <description>1、什么是Redis？ Redis本质上是一个Key-Value类型的内存数据库。很像memcached，整个数据库统统加载在内存当中进行操作</description>
    </item>
    
    <item>
      <title>Zookeeper集群部署</title>
      <link>http://www.mafool.com/post/1585818342/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585818342/</guid>
      <description>一. Zookeeper要点 zookeeper开放源码的分布式协调服务框架 ； zookeeper功能包括：配置维护、域名服务、分布式锁、组服务等</description>
    </item>
    
    <item>
      <title>Gomock单元测试</title>
      <link>http://www.mafool.com/posts/2f086c092ed75ec827a508d5daea97cd/</link>
      <pubDate>Sat, 13 Apr 2019 00:31:46 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/2f086c092ed75ec827a508d5daea97cd/</guid>
      <description>使用 Gomock 进行单元测试 在实际项目中，需要进行单元测试的时候。却往往发现有一大堆依赖项。这时候就是 Gomock 大显身手的时候了 Gomock 是 Go 语言的一个 mock 框架，官方的</description>
    </item>
    
    <item>
      <title>Linux - 实现免密登录</title>
      <link>http://www.mafool.com/posts/bdbe76b547376a30e6d68f62f36d397b/</link>
      <pubDate>Thu, 11 Apr 2019 13:19:13 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/bdbe76b547376a30e6d68f62f36d397b/</guid>
      <description>一. 生成密钥对 如果本地已存在密钥文件，则可跳过该步骤（可与git等工具共享密钥文件）。 在本地生成~/.ssh/id_rsa(密钥)和~/.s</description>
    </item>
    
    <item>
      <title>Redis实现主从复制</title>
      <link>http://www.mafool.com/post/1585819764/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585819764/</guid>
      <description>一. 配置主从概述 主从复制(Replication)：也叫主从同步，它是将Redis主服务器的数据同步到任意数量的从服务器上，同步使用的是发布</description>
    </item>
    
    <item>
      <title>Go精编100道题</title>
      <link>http://www.mafool.com/post/1585726239/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585726239/</guid>
      <description>Golang精编100题 能力模型 级别 模型 初级 primary 熟悉基本语法，能够看懂代码的意图； 在他人指导下能够完成用户故事的开发，编写的代码符合Clean</description>
    </item>
    
    <item>
      <title>Go面试自测系列</title>
      <link>http://www.mafool.com/post/1585725972/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585725972/</guid>
      <description>2、struct能不能比较 因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型 4</description>
    </item>
    
    <item>
      <title>Mysql面试题收录</title>
      <link>http://www.mafool.com/post/1585726446/</link>
      <pubDate>Tue, 09 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585726446/</guid>
      <description>事务四大特性 原子性(Atomicity) ：一个事务中的所有操作，要么全部完成，要么全部不完成。事务在执行过程中发生错误，会被回滚（Rollb</description>
    </item>
    
    <item>
      <title>日常工作中的正则表达式</title>
      <link>http://www.mafool.com/post/1585727291/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585727291/</guid>
      <description>1. VS code替换行尾字符 替换行尾双星号 1 \*\*r?$</description>
    </item>
    
    <item>
      <title>区块链分布式存储：生态大数据的存储新模式</title>
      <link>http://www.mafool.com/post/1585834756/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585834756/</guid>
      <description>前言 区块链，当之无愧的2019最靓的词，在科技领域闪闪发亮，在实体行业星光熠熠。 2019年的1024讲话，让区块链这个词焕然一新，以前它总是</description>
    </item>
    
    <item>
      <title>「转」iface 和 eface 的区别是什么</title>
      <link>http://www.mafool.com/post/1585590231003/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231003/</guid>
      <description>iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。 从源码层面看一下：</description>
    </item>
    
    <item>
      <title>「转」如何用 interface 实现多态</title>
      <link>http://www.mafool.com/post/1585590231005/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231005/</guid>
      <description>Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。 多态是一种运行期的行为，它有以下几</description>
    </item>
    
    <item>
      <title>「转」接口的动态类型和动态值</title>
      <link>http://www.mafool.com/post/1585590231006/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231006/</guid>
      <description>从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动</description>
    </item>
    
    <item>
      <title>「转」接口的构造过程是怎样的</title>
      <link>http://www.mafool.com/post/1585590231007/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231007/</guid>
      <description>我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。 为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。 来看一个</description>
    </item>
    
    <item>
      <title>值接收者和指针接收者的区别</title>
      <link>http://www.mafool.com/post/1585590231004/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231004/</guid>
      <description>方法 结构体变量和结构体对象，可以任意调用结构体(值接受者或指针接受者)方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type demo struct{} // 值接受 func (demo) foo() { fmt.Println(&amp;#34;FOO&amp;#34;) } // 指</description>
    </item>
    
    <item>
      <title>Go语言变量逃逸分析</title>
      <link>http://www.mafool.com/posts/21a9dcd7220eb509dbc8e49fee882300/</link>
      <pubDate>Fri, 15 Mar 2019 00:59:07 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/21a9dcd7220eb509dbc8e49fee882300/</guid>
      <description>Go 内存逃逸详细分析 Slice 怪异现象分析实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34; ) func main(){ s := []byte(&amp;#34;&amp;#34;) s1 := append(s, &amp;#39;a&amp;#39;) s2 := append(s, &amp;#39;b&amp;#39;) // 如果有此行，打印的结果是 a b，否</description>
    </item>
    
    <item>
      <title>TOML配置文件管理</title>
      <link>http://www.mafool.com/posts/d8411bdf00046a3195c31dd15e76a472/</link>
      <pubDate>Fri, 15 Feb 2019 01:07:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/d8411bdf00046a3195c31dd15e76a472/</guid>
      <description>配置工具的选择 一个项目通常是有很多配置的，比如PHP的php.ini文件、Nginx的server.conf文件，那么Golang的项目又适</description>
    </item>
    
    <item>
      <title>Mysql配置文件管理</title>
      <link>http://www.mafool.com/post/1585906809/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585906809/</guid>
      <description>一. 配置管理 1. 查看配置文件路径： mysql会使用以下优先级去加载配置文件。 1 $ mysql --help|grep my.cnf 2.查看启动配置项： 包含服务目录、插件、数据、日志目录和</description>
    </item>
    
    <item>
      <title>Nginx笔记 - URL重写</title>
      <link>http://www.mafool.com/posts/6002acef2ec39912a9491a62a269c8bb/</link>
      <pubDate>Sun, 13 Jan 2019 14:34:59 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/6002acef2ec39912a9491a62a269c8bb/</guid>
      <description>URL重写 URL重写是指将一个URL请求重新写成网站可以处理的另一个URL的过程。如将http://www.demo.com/product</description>
    </item>
    
    <item>
      <title>Nginx笔记 - 反向代理</title>
      <link>http://www.mafool.com/posts/9988bc1712a93bf24869c8d46a841045/</link>
      <pubDate>Sun, 13 Jan 2019 14:34:59 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/9988bc1712a93bf24869c8d46a841045/</guid>
      <description>一. 正向代理 正向代理是一种客户端代理，即代理完成客户端请求的工作，如使用V P N科学上网，访问Google，就是正向代理，正向代理不是本文的重</description>
    </item>
    
    <item>
      <title>Nginx笔记 - 基础配置</title>
      <link>http://www.mafool.com/posts/5c422e057c1204ac1f123660275788ae/</link>
      <pubDate>Sun, 13 Jan 2019 14:34:59 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/5c422e057c1204ac1f123660275788ae/</guid>
      <description>一. 基本模块 全局块： 配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引</description>
    </item>
    
    <item>
      <title>Nginx笔记 - 数据压缩</title>
      <link>http://www.mafool.com/posts/6b6d0da4906b7118c0b6dc8611cc399c/</link>
      <pubDate>Sun, 13 Jan 2019 14:34:59 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/6b6d0da4906b7118c0b6dc8611cc399c/</guid>
      <description>前言 gzip是nginx服务器的ngx_http_gzip_module模块提供的在线实时数据压缩功能。通过开启gzip功能，可对服务器响应</description>
    </item>
    
    <item>
      <title>接口转换的原理</title>
      <link>http://www.mafool.com/post/1585590232/</link>
      <pubDate>Mon, 31 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590232/</guid>
      <description>通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接</description>
    </item>
    
    <item>
      <title>类型转换和断言的区别</title>
      <link>http://www.mafool.com/post/1585590231/</link>
      <pubDate>Mon, 31 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590231/</guid>
      <description>Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于</description>
    </item>
    
    <item>
      <title>编译器自动检测类型是否实现接口</title>
      <link>http://www.mafool.com/post/1585590230/</link>
      <pubDate>Mon, 31 Dec 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585590230/</guid>
      <description>经常看到一些开源库里会有一些类似下面这种奇怪的用法： 1 var _ io.Writer = (*myWriter)(nil) 这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此</description>
    </item>
    
    <item>
      <title>数据排序之TopK问题</title>
      <link>http://www.mafool.com/posts/d6bafcadfff4b121d2d6f4bad1f1a5cb/</link>
      <pubDate>Mon, 10 Dec 2018 23:35:06 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/d6bafcadfff4b121d2d6f4bad1f1a5cb/</guid>
      <description>数据排序之TopK问题 前言 在大规模数据处理中，常遇到的一类问题是，在海量数据中找出出现频率最高的前K个数，或者从海量数据中找出最大的前K个数</description>
    </item>
    
    <item>
      <title>如何从外部访问Kubernetes集群中的应用？</title>
      <link>http://www.mafool.com/2018/11/28/access-application-from-outside/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/11/28/access-application-from-outside/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道，kubernetes的Cluster Network属于私有网络，只能在cluster Network内部才能访问部署的应用，那如何才能将Kubernetes集群中的应用暴露到外部网络，为外部用户提供服务呢？本文探讨了从外部网络访问kubernetes cluster中应用的几种实现方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>采用Istio实现灰度发布(金丝雀发布)</title>
      <link>http://www.mafool.com/2018/11/08/istio-canary-release/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/11/08/istio-canary-release/</guid>
      <description>灰度发布（又名金丝雀发布）介绍 当应用上线以后，运维面临的一大挑战是如何能够在不影响已上线业务的情况下进行升级。做过产品的同学都清楚，不管在发</description>
    </item>
    
    <item>
      <title>使用Istio实现应用流量转移</title>
      <link>http://www.mafool.com/2018/11/07/istio-traffic-shifting/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/11/07/istio-traffic-shifting/</guid>
      <description>&lt;p&gt;关于Istio的更多内容请参考&lt;a href=&#34;http://istio.doczh.cn/&#34;&gt;istio中文文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原文参见&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/traffic-shifting.html&#34;&gt;Traffic Shifting&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本任务将演示如何将应用流量逐渐从旧版本的服务迁移到新版本。通过Istio，可以使用一系列不同权重的规则（10%，20%，··· 100%）将流量平缓地从旧版本服务迁移到新版本服务。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Istio及Bookinfo示例程序安装试用笔记</title>
      <link>http://www.mafool.com/2018/11/04/istio-install_and_example/</link>
      <pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/11/04/istio-install_and_example/</guid>
      <description>&lt;h2 id=&#34;服务网格简介&#34;&gt;服务网格简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务网格&lt;/strong&gt;（Service Mesh）是为解决微服务的通信和治理而出现的一种&lt;strong&gt;架构模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务网格将服务间通讯以及与此相关的管理控制功能从业务程序中下移到一个基础设施层，从而彻底隔离了业务逻辑和服务通讯两个关注点。采用服务网格后，应用开发者只需要关注并实现应用业务逻辑。服务之间的通信，包括服务发现，通讯的可靠性，通讯的安全性，服务路由等由服务网格层进行处理，并对应用程序透明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker搭建Wordpress博客</title>
      <link>http://www.mafool.com/post/1585730181/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585730181/</guid>
      <description>前言 WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。WordPress具有插件架构和模板系统。截至20</description>
    </item>
    
    <item>
      <title>面试题汇总</title>
      <link>http://www.mafool.com/posts/99a7e89b9b8052e68f39909ef7fc0fc1/</link>
      <pubDate>Sat, 11 Aug 2018 00:13:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/99a7e89b9b8052e68f39909ef7fc0fc1/</guid>
      <description>[TOC] 1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？ Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。 2. 无缓</description>
    </item>
    
    <item>
      <title>Java环境部署</title>
      <link>http://www.mafool.com/post/1585671937/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585671937/</guid>
      <description>安装JRE/JDK 官网 JRE： http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html 网盘 JDK： http://pan.baidu.com/s/1i4LeazV 网盘 JRE： http://pan.baidu.com/s/1i5p7NfR 需要点击Accept License Agreement ，获取临时授权下载地址 可选择通版本或服务器版的jre，J</description>
    </item>
    
    <item>
      <title>Mysql数据库设计范式</title>
      <link>http://www.mafool.com/post/1585731112/</link>
      <pubDate>Fri, 03 Aug 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585731112/</guid>
      <description>前言 NORMALIZATION是一种数据库设计技术，它以减少数据冗余和依赖性的方式组织表。规范化将较大的表划分为较小的表，并使用关系将它们链</description>
    </item>
    
    <item>
      <title>「转」Raft共识算法</title>
      <link>http://www.mafool.com/post/1585750452/</link>
      <pubDate>Wed, 27 Jun 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585750452/</guid>
      <description>Raft共识算法 多个拜占庭将军要如何在可能有叛徒、信使可能被策反或者暗杀的情况下达成是否要进攻的一致性决定？还不了解的先看看上一篇《拜占庭将</description>
    </item>
    
    <item>
      <title>A syntax example for markdown</title>
      <link>http://www.mafool.com/post/1585109288/</link>
      <pubDate>Fri, 15 Jun 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585109288/</guid>
      <description>欢迎使用Markdown在线编辑器MdEditor Markdown是一种轻量级的「标记语言」 Markdown是一种可以使用普通文本编辑器编写</description>
    </item>
    
    <item>
      <title>Istio v1aplha3 routing API介绍(译文）</title>
      <link>http://www.mafool.com/2018/06/04/introducing-the-istio-v1alpha3-routing-api/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/06/04/introducing-the-istio-v1alpha3-routing-api/</guid>
      <description>&lt;p&gt;到目前为止，Istio提供了一个简单的API来进行流量管理，该API包括了四种资源：RouteRule，DestinationPolicy，EgressRule和Ingress（直接使用了Kubernets的Ingress资源）。借助此API，用户可以轻松管理Istio服务网格中的流量。该API允许用户将请求路由到特定版本的服务，为弹性测试注入延迟和失败，添加超时和断路器等等，所有这些功能都不必更改应用程序本身的代码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Istio 0.8 Release发布</title>
      <link>http://www.mafool.com/2018/06/02/istio08/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/06/02/istio08/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在6月1日这一天的早上，Istio社区宣布发布0.8 Release，除了常规的故障修复和性能改进外，这个儿童节礼物里面还有什么值得期待内容呢？让我们来看一看：&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Istio Sidecar自动注入原理</title>
      <link>http://www.mafool.com/2018/05/23/istio-auto-injection-with-webhook/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/05/23/istio-auto-injection-with-webhook/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Kubernets 1.9版本引入了Admission Webhook(web 回调)扩展机制，通过Webhook,开发者可以非常灵活地对Kubernets API Server的功能进行扩展，在API Server创建资源时对资源进行验证或者修改。&lt;/p&gt;
&lt;p&gt;使用webhook的优势是不需要对API Server的源码进行修改和重新编译就可以扩展其功能。插入的逻辑实现为一个独立的web进程，通过参数方式传入到kubernets中，由kubernets在进行自身逻辑处理时对扩展逻辑进行回调。&lt;/p&gt;
&lt;p&gt;Istio 0.7版本就利用了Kubernets webhook实现了sidecar的自动注入。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微服务安全沉思录之一</title>
      <link>http://www.mafool.com/2018/05/22/user_authentication_authorization/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/05/22/user_authentication_authorization/</guid>
      <description>这段时间对之前微服务安全相关的一些想法进行了进一步总结和归纳，理清了在之前文章里面没有想得太清楚的地方，例如服务间的认证与鉴权以及用户身份在</description>
    </item>
    
    <item>
      <title>微服务安全沉思录之三</title>
      <link>http://www.mafool.com/2018/05/23/external_system_auth/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/05/23/external_system_auth/</guid>
      <description>外部系统访问控制 除用户访问和微服务之间的相互访问外，外部的第三方系统也可能需要访问系统内部的微服务。例如在上一篇博客的网上商店例子中，外部的</description>
    </item>
    
    <item>
      <title>微服务安全沉思录之二</title>
      <link>http://www.mafool.com/2018/05/23/service_2_service_auth/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/05/23/service_2_service_auth/</guid>
      <description>&lt;h2 id=&#34;服务间认证与鉴权&#34;&gt;服务间认证与鉴权&lt;/h2&gt;
&lt;p&gt;除来自用户的访问请求以外，微服务应用中的各个微服务相互之间还有大量的访问，包括下述场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户间接触发的微服务之间的相互访问&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
例如在一个网上商店应用中，用户访问购物车微服务进行结算时，购物车微服务可能需要访问用户评级微服务获取用户的会员级别，以得到用户可以享受购物折扣。&lt;/li&gt;
&lt;li&gt;非用户触发的微服务之间的相互访问&lt;!-- raw HTML omitted --&gt;&lt;br&gt;
例如数据同步或者后台定时任务导致的微服务之间的相互访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据应用系统的数据敏感程度的不同，对于系统内微服务的相互访问可能有不同的安全要求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mysql用户权限管理</title>
      <link>http://www.mafool.com/post/1585906664/</link>
      <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585906664/</guid>
      <description>一. 用户管理 1. 查询用户 1 SELECT host,user FROM mysql.user; 2. 添加用户 可使用create或grant(当用户不存在时创建用户，并授权，参考授权管理)命名创建用户。 1 CREATE USER</description>
    </item>
    
    <item>
      <title>Mysql安装教程</title>
      <link>http://www.mafool.com/post/1585906284/</link>
      <pubDate>Wed, 02 May 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585906284/</guid>
      <description>1.准备环境 下载与操作系统相兼容的Mysql版本，查看安装向导 。 1 2 3 # 查看服务器操作系统版本信息 $ uname -r #lunix内核版本 3.10.0...x86_64 $ lsb_release -d #lin</description>
    </item>
    
    <item>
      <title>Yaml基础语法示例</title>
      <link>http://www.mafool.com/post/1585672788/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585672788/</guid>
      <description>在线Demo： http://nodeca.github.io/js-yaml 语法规则 大小写敏感 符号加空格▲ 用缩进表示层级 左对齐表示同级 禁止制表符 井号表示注释 减号表示序列符 冒号表示键值符 大于号折行 双叹号</description>
    </item>
    
    <item>
      <title>Git - 常用命令</title>
      <link>http://www.mafool.com/posts/0d78ecbaabf7de26111f39aa46e471fe/</link>
      <pubDate>Sat, 21 Apr 2018 01:25:50 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/0d78ecbaabf7de26111f39aa46e471fe/</guid>
      <description>[TOC] 1. 远程仓库 1 2 3 4 5 git clone git@xxxx.git -b develop #从develop分支克隆 git clone --branch [tags标签] [git地址] git remote -v #远程仓库 git remote set-url origin git@xxx:sybs/xxx.git #修改url git remote prune origin</description>
    </item>
    
    <item>
      <title>Git - 基础入门</title>
      <link>http://www.mafool.com/posts/38cbcea795d75f092237689286080b6a/</link>
      <pubDate>Sat, 21 Apr 2018 00:52:31 +0800</pubDate>
      
      <guid>http://www.mafool.com/posts/38cbcea795d75f092237689286080b6a/</guid>
      <description>推荐链接 Git官网 官方汉化教程 runoob教程 目录结构 创建一个work目录，并采用git init命令初始化git仓库。该命令会在工作目录下生</description>
    </item>
    
    <item>
      <title>Helm介绍</title>
      <link>http://www.mafool.com/2018/04/16/using-helm-to-deploy-to-kubernetes/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/04/16/using-helm-to-deploy-to-kubernetes/</guid>
      <description>前言 Helm是Kubernetes生态系统中的一个软件包管理工具。本文将介绍为何要使用Helm进行Kubernetes软件包管理，澄清Hel</description>
    </item>
    
    <item>
      <title>Service Mesh 和 API Gateway的关系探讨（译文）</title>
      <link>http://www.mafool.com/2018/04/11/service-mesh-vs-api-gateway/</link>
      <pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/04/11/service-mesh-vs-api-gateway/</guid>
      <description>Service Mesh vs API Gateway 在前一篇关于Service Mesh的文章中,我提到了几个关于Service Mesh和API Gateway之间关系的问题，在本篇文章</description>
    </item>
    
    <item>
      <title>谈谈微服务架构中的基础设施：Service Mesh与Istio</title>
      <link>http://www.mafool.com/2018/03/29/what-is-service-mesh-and-istio/</link>
      <pubDate>Thu, 29 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/03/29/what-is-service-mesh-and-istio/</guid>
      <description>&lt;h2 id=&#34;微服务架构的演进&#34;&gt;微服务架构的演进&lt;/h2&gt;
&lt;p&gt;作为一种架构模式，微服务将复杂系统切分为数十乃至上百个小服务，每个服务负责实现一个独立的业务逻辑。这些小服务易于被小型的软件工程师团队所理解和修改，并带来了语言和框架选择灵活性，缩短应用开发上线时间，可根据不同的工作负载和资源要求对服务进行独立缩扩容等优势。&lt;/p&gt;
&lt;p&gt;另一方面，当应用被拆分为多个微服务进程后，进程内的方法调用变成了了进程间的远程调用。引入了对大量服务的连接、管理和监控的复杂性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何配置docker使用HTTP代理</title>
      <link>http://www.mafool.com/post/KDCHSKIWJKJNVBOE/</link>
      <pubDate>Tue, 13 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/post/KDCHSKIWJKJNVBOE/</guid>
      <description>&lt;h3 id=&#34;设置docker使用http-proxy&#34;&gt;设置docker使用http proxy&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f3f3&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#f0f3f3&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;background-color:#f0f3f3&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;sudo &lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;etc&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;default&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;docker

export http_proxy&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;http://127.0.0.1:3128/&amp;#34;&lt;/span&gt;
export https_proxy&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;http://127.0.0.1:3128/&amp;#34;&lt;/span&gt;
export HTTP_PROXY&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;http://127.0.0.1:3128/&amp;#34;&lt;/span&gt;
export HTTPS_PROXY&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;http://127.0.0.1:3128/&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Go经典编程练习题</title>
      <link>http://www.mafool.com/post/1585633378/</link>
      <pubDate>Sun, 18 Feb 2018 00:00:00 +0800</pubDate>
      
      <guid>http://www.mafool.com/post/1585633378/</guid>
      <description>1.排列组合 题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 分析：三层嵌套循环，时间复杂度为O(n^3) 1</description>
    </item>
    
    <item>
      <title>如何使用非root用户执行docker命令</title>
      <link>http://www.mafool.com/2018/02/09/docker-without-sudo/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/02/09/docker-without-sudo/</guid>
      <description>Add the docker group if it doesn&amp;rsquo;t already exist: sudo groupadd docker Add the connected user &amp;ldquo;$USER&amp;rdquo; to the docker group. Change the user name to match your preferred user if you do not want to use your current user: sudo gpasswd -a $USER docker Either do a newgrp docker or log out/in to activate the changes to groups.</description>
    </item>
    
    <item>
      <title>如何构建安全的微服务应用？</title>
      <link>http://www.mafool.com/2018/05/22/user_authentication_authorization/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/05/22/user_authentication_authorization/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;微服务架构的引入为软件应用带来了诸多好处：包括小开发团队，缩短开发周期，语言选择灵活性，增强服务伸缩能力等。与此同时，也引入了分布式系统的诸多复杂问题。其中一个挑战就是如何在微服务架构中实现一个灵活，安全，高效的认证和鉴权方案。本文将尝试就此问题进行一次比较完整的探讨。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx开源Service Mesh组件Nginmesh安装指南</title>
      <link>http://www.mafool.com/2018/01/02/nginmesh-install/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/2018/01/02/nginmesh-install/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Nginmesh是NGINX的Service Mesh开源项目，用于Istio服务网格平台中的数据面代理。它旨在提供七层负载均衡和服务路由功能，与Istio集成作为sidecar部署，并将以“标准，可靠和安全的方式”使得服务间通信更容易。Nginmesh在今年底已经连续发布了0.2和0.3版本，提供了服务发现，请求转发，路由规则，性能指标收集等功能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>https://blog.csdn.net/yjclsx/article/details/86537095
https://www.cnblogs.com/sunfie/p/6653778.html
1 2 3 4 5 6 7 8 9  curl --user elastic:123456 -H &amp;#34;Content-Type: application/json&amp;#34; -XPUT &amp;#39;http://localhost:9200/store/books/2&amp;#39; -d &amp;#39;{ &amp;#34;title&amp;#34;: &amp;#34;Elasticsearch Blueprints&amp;#34;, &amp;#34;name&amp;#34; : { &amp;#34;first&amp;#34; : &amp;#34;Vineeth&amp;#34;, &amp;#34;last&amp;#34; : &amp;#34;Mohan&amp;#34; }, &amp;#34;publish_date&amp;#34;:&amp;#34;2015-06-06&amp;#34;, &amp;#34;price&amp;#34;:&amp;#34;35.99&amp;#34; }&amp;#39;    curl -XPOST --user admin:admin &#39;http://XXXX:9200/XXXX/XXX/_delete_by_query&#39; -H &amp;quot;Content-Type: application/json&amp;quot; -d &#39;{ &amp;quot;query&amp;quot;:{&amp;quot;match_all&amp;quot;:{}}}&#39;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[toc] 一. Logstash该要 二. 安装Logstash 1 2 3 4 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.3.2.tar.gz tar -zxvf logstash-6.3.2.tar.gz -C /usr/local/elk/ mv /usr/local/elk/logstash-6.3.2 /usr/local/elk/logstash ln -s /usr/local/elk/logstash/bin/logstash /usr/local/bin/logstash 执行logstash -e &#39;input{stdin{}} output{stdout{c</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>官网：https://www.elastic.co/downloads 目录： [TOC] 一. ELK架构 二. 安装JDK/JRE环境 请参考: 安装JDK15</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.1 Go语言创世纪 Go语言最初由Google公司的Robert Griesemer、Ken Thompson和Rob Pike三个大牛于2007年开</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.2 Hello, World 的革命 在创世纪章节中我们简单介绍了Go语言的演化基因族谱，对其中来自于贝尔实验室的特有并发编程基因做了重点介绍，最后引出了Go语言版的</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.3 数组、字符串和切片 在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash表（hash表</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.4 函数、方法和接口 函数对应操作序列，是程序的基本组成元素。Go语言中的函数有具名和匿名之分：具名函数一般对应于包级的函数，是匿名函数的一种特</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.5 面向并发的内存模型 在早期，CPU都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.6 常见的并发模式 Go语言最吸引人的地方是它内建的并发支持。Go语言并发体系的理论是C.A.R Hoare在1978年提出的CSP（Commun</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.7 错误和异常 错误处理是每个编程语言都要考虑的一个重要话题。在Go语言的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分。 在</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1.8 补充说明 本书定位是Go语言进阶图书，因此读者需要有一定的Go语言基础。如果对Go语言不太了解，作者推荐通过以下资料开始学习Go语言。首先是</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.3 常量和全局变量 程序中的一切变量的初始值都直接或间接地依赖常量或常量表达式生成。在Go语言中很多变量是默认零值初始化的，但是Go汇编中定义的</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.5 控制流 程序主要有顺序、分支和循环几种执行流程。本节主要讨论如何将Go语言的控制流比较直观地转译为汇编程序，或者说如何以汇编思维来编写Go语</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.6 再论函数 在前面的章节中我们已经简单讨论过Go的汇编函数，但是那些主要是叶子函数。叶子函数的最大特点是不会调用其他函数，也就是栈的大小是可以</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.7 汇编语言的威力 汇编语言的真正威力来自两个维度：一是突破框架限制，实现看似不可能的任务；二是突破指令限制，通过高级指令挖掘极致的性能。对于第</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.8 例子：Goroutine ID 在操作系统中，每个进程都会有一个唯一的进程编号，每个线程也有自己唯一的线程编号。同样在Go语言中，每个Gorou</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>3.9 Delve调试器 目前Go语言支持GDB、LLDB和Delve几种调试器。其中GDB是最早支持的调试工具，LLDB是macOS系统推荐的标准</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.1 RPC入门 RPC是远程过程调用的简称，是分布式系统中不同节点间流行的通信方式。在互联网时代，RPC已经和IPC一样成为一个不可或缺的基础构</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.2 Protobuf Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protob</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.3 玩转RPC 在不同的场景中RPC有着不同的需求，因此开源的社区就诞生了各种RPC框架。本节我们将尝试Go内置RPC框架在一些比较特殊场景的用</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.4 gRPC入门 gRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP/2协议设计，可以基于一个HT</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.5 gRPC进阶 作为一个基础的RPC框架，安全和扩展是经常遇到的问题。本节将简单介绍如何对gRPC进行安全认证。然后介绍通过gRPC的截取器特</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.6 gRPC和Protobuf扩展 目前开源社区已经围绕Protobuf和gRPC开发出众多扩展，形成了庞大的生态。本节我们将简单介绍验证器和R</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.7 pbgo: 基于Protobuf的框架 pbgo是我们专门针对本节内容设计的较为完整的迷你框架，它基于Protobuf的扩展语法，通过插件自动生成rp</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.8 grpcurl工具 Protobuf本身具有反射功能，可以在运行时获取对象的Proto文件。gRPC同样也提供了一个名为reflection</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>4.9 补充说明 目前专门讲述RPC的图书比较少。目前Protobuf和gRPC的官网都提供了详细的参考资料和例子。本章重点讲述了Go标准库的RPC</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.1 Web 开发简介 因为Go的net/http包提供了基础的路由函数组合与丰富的功能函数。所以在社区里流行一种用Go编写API不需要框架的观点，在我</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.2 router 请求路由 在常见的Web框架中，router是必备的组件。Go语言圈子里router也时常被称为http的multiplexer。在上一节</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.3 中间件 本章将对现在流行的Web框架中的中间件(middleware)技术原理进行分析，并介绍如何使用中间件技术将业务和非业务代码功能进行解</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.4 validator请求校验 社区里曾经有人用图 5-10来嘲笑PHP： 图 5-10 validator流程 这其实是一个语言无关的场景，需要进行字段校验的</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.5 Database 和数据库打交道 本节将对db/sql官方标准库作一些简单分析，并介绍一些应用比较广泛的开源ORM和SQL Builder。并从企业级应用开发</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.6 Ratelimit 服务流量限制 计算机程序可依据其瓶颈分为磁盘IO瓶颈型，CPU计算瓶颈型，网络带宽瓶颈型，分布式场景下有时候也会外部系统而导致自身瓶颈。 W</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.7 layout 常见大型 Web 项目分层 流行的Web框架大多数是MVC框架，MVC这个概念最早由Trygve Reenskaug在1978年提出，为了能够对GU</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.8 接口和表驱动开发 在Web项目中经常会遇到外部依赖环境的变化，比如： 公司的老存储系统年久失修，现在已经没有人维护了，新的系统上线也没有考虑平</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.9 灰度发布和 A/B test 中型的互联网公司往往有着以百万计的用户，而大型互联网公司的系统则可能要服务千万级甚至亿级的用户需求。大型系统的请求流入往往是</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>5.10 补充说明 现代的软件工程是离不开Web的，广义地来讲，Web甚至可以不用非得基于http协议。只要是CS或者BS架构，都可以认为是Web系统</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.2 分布式锁 在单机程序并发或并行修改全局变量时，需要对修改行为加锁以创造临界区。为什么需要加锁呢？我们看看在不加锁的情况下并发计数会发生什么情</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.3 延时任务系统 我们在做系统时，很多时候是处理实时的任务，请求来了马上就处理，然后立刻给用户以反馈。但有时也会遇到非实时的任务，比如确定的时间</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.4 分布式搜索引擎 在Web一章中，我们提到MySQL很脆弱。数据库系统本身要保证实时和强一致性，所以其功能设计上都是为了满足这种一致性需求。比</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.5 负载均衡 本节将会讨论常见的分布式系统负载均衡手段。 6.5.1 常见的负载均衡思路 如果我们不考虑均衡的话，现在有n个服务节点，我们完成业务流程只需要从</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.6 分布式配置管理 在分布式系统中，常困扰我们的还有上线问题。虽然目前有一些优雅重启方案，但实际应用中可能受限于我们系统内部的运行情况而没有办法</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.7 分布式爬虫 互联网时代的信息爆炸是很多人倍感头痛的问题，应接不暇的新闻、信息、视频，无孔不入地侵占着我们的碎片时间。但另一方面，在我们真正需</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>6.8 补充说明 分布式是很大的领域，本章中的介绍只能算是对领域的管中窥豹。因为大型系统流量大，并发高，所以往往很多朴素的方案会变得难以满足需求。人</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Channel 发送和接收元素的本质是什么？ All transfer of value on the go channels happens with the copy of value. 就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Channel 可能会引发 goroutine 泄漏。 泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>数据结构 底层数据结构需要看源码，版本为 go 1.9.2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type hchan struct { // chan 里元素数量 qcount uint // chan 底层循</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Channel 和 goroutine 的结合是 Go 并发编程的大杀器。而 Channel 的实际应用也经常让人眼前一亮，通过与 select，cancel，timer 等结合，它能实现各种各样的功</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Do not communicate by sharing memory; instead, share memory by communicating. 不要通过共享内存来通信，而要通过通信来实现内存共享。 这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。 CSP 经常被认为是 Go 在并</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>源码分析 我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，再根据一个实际的例子来具体研究。 接收操作有两种写法，一种带 &amp;ldquo;o</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { ch := make(chan</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>维基百科上给的定义： In computer science, the happened-before relation (denoted: -&amp;gt;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow). 简单来说就是如果事件 a 和</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>关闭某个 channel，会执行函数 closechan： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>源码分析 发送操作最终转化为 chansend 函数，直接上源码，同样大部分都注释了，可以看懂主流程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>关于 channel 的使用，有几点不方便的地方： 在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。 关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>总结一下操作 channel 的结果： 操作 nil channel closed channel not nil, not closed channel close panic panic 正常关闭 读 &amp;lt;- ch 阻塞 读到对应类型的零值 阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>当文中提及目前、目前版本等字眼时均指 Go 1.14，此外，文中所有 go 命令版本均为 Go 1.14。 GC 的认识 1. 什么是 GC，有什么作用？ GC，全称 Garbage Col</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一讲讲完了 main goroutine 的诞生，它不是第一个，算上 g0，它要算第二个了。不过，我们要考虑的就是这个 goroutine，它会真正执行用户代码。 g0 栈用于</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一讲说到调度器将 main goroutine 推上舞台，为它铺好了道路，开始执行 runtime.main 函数。这一讲，我们探索 main goroutine 以及普通 goroutine 从执行到退出的整个过程。 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。 情形 说明 使用关键字 go go 创建一个新的 gorout</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？ 参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>G、P、M 是 Go 调度器的三个核心组件，各司其职。在它们精密地配合下，Go 调度器得以高效运转，这也是 Go 天然支持高并发的内在动力。今天这篇文章我们</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>在 schedule 函数中，我们简单提过找一个 runnable goroutine 的过程，这一讲我们来详细分析源码。 工作线程 M 费尽心机也要找到一个可运行的 goroutine，这是它的工作和</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一讲我们讲完了 Go scheduler 的初始化，现在调度器一切就绪，就差被调度的实体了。本文就来讲述 main goroutine 是如何诞生，并且被调度的。 继续看代码，前面我们完成了 schedinit</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一讲新创建了一个 goroutine，设置好了 sched 成员的 sp 和 pc 字段，并且将其添加到了 p0 的本地可运行队列，坐等调度器的调度。 我们继续看代码。搞了</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一节，我们讲完 main goroutine 以及普通 goroutine 的退出过程。main goroutine 退出后直接调用 exit(0) 使得整个进程退出，而普通 goroutine 退出后，则进行了一系列的调用，最终又切到 g0 栈，</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>在 runtime.main() 函数中，执行 runtime_init() 前，会启动一个 sysmon 的监控线程，执行后台监控任务： 1 2 3 4 systemstack(func() { // 创建监控线程，该线程独立于调度器，不需要跟 p 关联即可运行 newm(sysmon, nil) })</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>由于 Go 语言是协作式的调度，不会像线程那样，在时间片用完后，由 CPU 中断任务强行将其调度走。对于 Go 语言中运行时间过长的 goroutine，Go scheduler 有</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>什么是 sheduler Go 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>我们都知道，Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go scheduler 的职责就是将所有处于 runnable 的 goroutines 均匀分布到在 P 上运行的 M。 当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。看看这是什么精神！自</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>上一节我们说完了 GPM 结构体，这一讲，我们来研究 Go sheduler 结构体，以及整个调度器的初始化过程。 Go scheduler 在源码中的结构体为 schedt，保存调度器的状态信息</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>接口定义了一种规范，描述了类的行为和功能，而不做具体实现。 C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。 从源码层面看一下：</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>方法 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。 多态是一种运行期的行为，它有以下几</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。 为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。 来看一个</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。 类型转换、类型断言本质都是把一个类型转换成另外一个类型。</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>经常看到一些开源库里会有一些类似下面这种奇怪的用法： 1 var _ io.Writer = (*myWriter)(nil) 这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>map 不是线程安全的。 在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于1），则直接 panic。赋值和删除函数在检测完写标</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>写操作底层的执行函数是 mapdelete： 1 func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) 根据 key 类型的不同，删除操作会被优化成更具体的函数： key 类型 删除 uint32 mapdelete_fast32(t *maptype, h *hmap, key uint32) uint64 mapdelete_fast64(t *maptype, h</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>什么是 map 维基百科里这样定义 map： In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection. 简单说明一下：在计算机科学里，被称</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 mapassign 函数。 实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>无法对 map 的 key 或 value 进行取址。以下代码不能通过编译： 1 2 3 4 5 6 7 8 9 package main import &amp;#34;fmt&amp;#34; func main() { m := make(map[string]int) fmt.Println(&amp;amp;m[&amp;#34;qcrao&amp;#34;]) } 编译报错： 1 ./main.go:8:14: cannot take the address of m[&amp;#34;qcrao&amp;#34;] 如果通过其他 hack 的方式，例</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 上面说的是发生在多个协程同时读写同一个 map 的情况</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>map 深度相等的条件： 1 2 3 1、都为 nil 2、非空、长度相等，指向同一个 map 实体对象 3、相应的 key 指向的 value “深度”相等 直接将使用 map1 == map2 是错误的。这种写法</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>项目介绍 个人博客：https://qcrao.com 电子书地址：https://qcrao91.gitbook.io/go 本项目地址：htt</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 语言中反射的应用非常广：IDE 中的代码自动补全功能、对象序列化（encoding/json）、fmt 相关函数的实现、ORM（全称是：Obj</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>interface，它是 Go 语言实现抽象的一个非常强大的工具。当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>使用反射的常见场景有以下两种： 不能明确接口调用哪个函数，需要根据传入的参数在运行时决定。 不能明确传入函数的参数类型，需要在运行时处理任意对象</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>维基百科上反射的定义： 在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 语言中提供了一个函数可以完成此项功能： 1 func DeepEqual(x, y interface{}) bool DeepEqual 函数的参数是两个 interface，实际上也就是可以输入任意类型，输出 true 或者 flase 表示输入</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。 当 slice 作为函数参数时，</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>一般都是在向 slice 追加了元素之后，才会引起扩容。追加元素调用的是 append 函数。 先来看看 append 函数的原型： 1 func append(slice []Type, elems ...Type) []Type append 函数的参数长度可变，因此可以追加多</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>context 包的代码并不长，context.go 文件总共不到 500 行，其中还有很多大段的注释，代码可能也就 200 行左右的样子，是一个非常值得研究的代码库。 先看</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 1.7 标准库引入 context，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine 的运行状态、环境、现场等信息。 context 主要用来在 goroutine 之间传递上下文信息</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 常用来写后台服务，通常只需要几行代码，就可以搭建一个 http server。 在 Go 的 server 里，通常每来一个请求都会启动若干个 goroutine 同时工作：有些去数据库拿数</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1 2 3 4 type valueCtx struct { Context key, val interface{} } 它实现了两个方法： 1 2 3 4 5 6 7 8 9 10 func (c *valueCtx) String() string { return fmt.Sprintf(&amp;#34;%v.WithValue(%#v, %#v)&amp;#34;, c.Context, c.key, c.val) } func (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) } 由于它直接将 Context</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。 然而，Go 语言的指针相比 C 的指针</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>对于一个结构体，通过 offset 函数可以获取结构体成员的偏移量，进而获取成员的地址，读写该地址的内存，就可以达到改变成员值的目的。 这里有一个内存分配相</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>获取 slice 长度 通过前面关于 slice 的文章，我们知道了 slice header 的结构体定义： 1 2 3 4 5 6 // runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 调用 make 函数新建一个 s</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>这是一个非常精典的例子。实现字符串和 bytes 切片之间的转换，要求是 zero-copy。想一下，一般的做法，都需要遍历字符串或 bytes 切片，再挨个赋值。 完</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>我们从一个 Hello World 的例子开始： 1 2 3 4 5 6 7 package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 在项目根目录下执行： 1 go build -gcflags &amp;#34;-N -l&amp;#34; -o hello src/main.go -gcflags &amp;quot;-N -l&amp;quot; 是为了关闭编译器优化和函数内联，防止</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>直接在终端执行： 1 go 就能得到和 go 相关的命令简介： 和编译相关的命令主要是： 1 2 3 go build go install go run go build go build 用来编译指定 packages 里的源码文件以及它们的依赖包</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>我们从一个 Hello World 的例子开始： 1 2 3 4 5 6 7 package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } 当我们用键盘敲完上面的 hello world 代码时，保存在硬盘上的 hello.go 文件就是一个字节序列了，每个字</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>GoRoot 是 Go 的安装路径。mac 或 unix 是在 /usr/local/go 路径上，来看下这里都装了些什么： bin 目录下面： pkg 目录下面： Go 工具目录如下，其中比较重要的有编译器 compil</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>在编译原理中，分析指针动态范围的方法称之为逃逸分析。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。 Go语言的逃</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[TOC] Go核心团队 Rob Pike： Unix核心成员，Plan9的主要领导人，Inferno操作系统开发的主要领导人; Ken Thompson： 图灵奖得主，</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[TOC] 一. 操作系统 Unix中，目录即文件，包括存在、创建、读取(遍历)、修改、删除 1. 系统信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func SysInfo() { //机器</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>https://blog.51cto.com/9291927/2331980</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[TOC] Rust概述 Rust是由Mozilla员工“Graydon Hoare”于2006年开发的系统编程语言。他将这种语言描述为支持功能和命令范式</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>1 2  cargo new hello-world cd hello-world   1 2 3  vim Config.toml [dependencies] actix-web=&amp;#34;3&amp;#34;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  useactix_web::{web,App,HttpRequest,HttpServer,Responder};asyncfn greet(req: HttpRequest)-&amp;gt; implResponder{letname=req.match_info().get(&amp;#34;name&amp;#34;).unwrap_or(&amp;#34;World&amp;#34;);format!(&amp;#34;Hello 000{}!&amp;#34;,&amp;amp;name)}#[actix_web::main]asyncfn main()-&amp;gt; std::io::Result&amp;lt;()&amp;gt;{HttpServer::new(||{App::new().route(&amp;#34;/&amp;#34;,web::get().to(greet)).route(&amp;#34;/{name}&amp;#34;,web::get().to(greet))}).bind(&amp;#34;127.0.0.1:8080&amp;#34;)?.run().await}  1  cargo run   </description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[TOC] 一. 基础语法 二. 流程控制 1.if语句 语法：if;then;elif;then;else;fi; Shell风格 1 2 3 if [ $# -lt 1 ]; then echo &amp;#34</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.mafool.com/1/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.mafool.com/1/01/</guid>
      <description>[TOC] XXX性能测试报告 版本 作者 日期 Server_V1.0.0 王凤伟 2020-01-16 一． 概述 1.编写目的 编写该性能测试报告的目的主要用于说明系统性能的评估，为线上推广提供参考依 据 2.</description>
    </item>
    
  </channel>
</rss>
