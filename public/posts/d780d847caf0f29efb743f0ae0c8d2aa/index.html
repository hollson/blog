<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>码夫庄园-「转」Go之优雅代码之道</title>
    <meta name="keywords"
        content='码农,hugo,theme,blog,coder,geek,github,golang,技术,源码,代码,编程,程序员,主题,个人,博客,微服务,容器'>
    <meta name="description" content="Go 语言是一门简单、易学的编程语言，对于有编程背景的工程师来说，学习 Go 语言并写出能够运行的代码并不是一件困难的事情，对于之前有过其他语言经验的开发者来说，写什么语言都像自己学过的语言其实是有问题的，想要真正融入生态写出优雅的代码就一定要花一些时间和精力了解语言背后的设计哲学和最佳实践。" />

    
    <meta name="baidu-site-verification" content="v9szEmQLra" />
    <meta name="360-site-verification" content="d8e961f98fb655e4b8cf9439cfd9ac7f" />
    <meta name="sogou_site_verification" content="40NC9EdZDC" />
    <meta name="shenma-site-verification" content="3200e3042e92157713a3b0aceeecb20a_1586020187" />
    <meta name="google-site-verification" content="r8987bkunZHJeKut3ocu5NIJ5QEu53NA6Q_r7RrZ46c" />
    <meta name="msvalidate.01" content="893A2865ABC54AC2782D118536831056" />

    
    <link rel="shortcut icon" href="https://hollson.github.io/img/res/favicon.ico">
    

    

    <link crossorigin="anonymous" integrity="sha384-5kGFOAqgEKnuF6c2jk2JANKHZgYVt38Wn2dVJENtq1EBCP54/1uzXU5mpxqL8WjN"
        href="https://lib.baomitu.com/bulma/0.8.0/css/bulma.min.css" rel="stylesheet">

    <link rel="stylesheet" href="https://hollson.github.io/css/dooz.blog.css" />
    <script crossorigin="anonymous" integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh"
        src="https://lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script>

    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/jquery.share.min.js"></script>
    

    

    
    
<link rel="stylesheet" href="https://hollson.github.io/css/reward.css">


    <link href="https://hollson.github.io/css/fonts.googleapi.css" rel="stylesheet">
    <script src=https://hollson.github.io/js/dooz.blog.js></script>

    
    <script>
        $(document).ready(function () {
            $('.content a[href^="http"]').each(function () {
                $(this).attr('target', '_blank');
            });
        });

        $(document).on('click', '.modal-wechat', function () {
            $(".modal").addClass("is-active");
        });

        $(document).on('click', '.modal-background', function () {
            $(".modal").removeClass("is-active");
        });
    </script>
</head>

<body>
    
    
<section class="hero is-info is-medium"
    style="background-image: url('/img/res/blog.jpg');">
    <div class="hero-head">
        <nav class="navbar is-transparent container has-text-white">
    <div class="navbar-brand">
        <div class="navbar-item">
            <a class="title is-5 is-white" href="https://hollson.github.io/">码夫庄园</a>
        </div>

        
        <div class="navbar-burger burger" data-target="navbarExampleTransparentExample">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <div id="navbarExampleTransparentExample" class="navbar-menu has-text-dark">
        

        <div class="navbar-end">
            <a class="navbar-item" href='https://hollson.github.io/'>首页</a>
            <a class="navbar-item" href='https://hollson.github.io/archives'>归档 </a>
            <a class="navbar-item" href='https://hollson.github.io/about'>关于</a>
            <span class="navbar-item">
                <a class="button is-primary is-inverted" href="https://github.com/hollson/hugo-theme-dooz">
                    <span class="icon"><i class="fab fa-github"></i></span>
                    <span>主题</span>
                </a>
            </span>
        </div>
    </div>
</nav>
    </div>
    <div class="hero-body">
        <div class="container has-text-centered">
            <div class='container has-text-left column is-7'>
                
                <h1 class="title is-size-2" style="margin-bottom:0.2rem;">
                    
                    「转」Go之优雅代码之道
                    
                </h1>
                
                <span class="title is-size-6" style="font-style: italic;"> </span><br>
            </div>
        </div>
    </div>
</section>


    
    <div class="container">
        <div class="section">
            
<div class="columns">
    <div class="column is-9">
        <div class="tile is-child box">
            <div class="content">
                
                <nav class="level">
                    
                    <div class="level-left">
                        <div class="level-item">
                            <p class="subtitle is-size-6 has-text-grey-light" style="font-style: italic;">
    
     2019年8月7日,
    星期三 &middot;
    
    <i class="far fa-clock"></i>&nbsp; 32分钟阅读
</p>
                        </div>
                    </div>

                    
                    
                    <div class="share-component level-right" data-disabled="google,diandian,tencent,qzone"
                        data-description="Share.js - 一键分享到微博，QQ空间，腾讯微博，人人，豆瓣"
                        data-mobile-sites="weibo,qq,qzone,tencent">
                    </div>
                    
                </nav>
                <hr>
                
                <header>
                    <h2>目录</h2>
                </header>
                <nav id="TableOfContents">
  <ul>
    <li><a href="#写在前面">写在前面</a></li>
    <li><a href="#代码规范">代码规范</a>
      <ul>
        <li><a href="#辅助工具">辅助工具</a>
          <ul>
            <li><a href="#goimports">goimports</a></li>
            <li><a href="#golint">golint</a></li>
          </ul>
        </li>
        <li><a href="#自动化">自动化</a></li>
      </ul>
    </li>
    <li><a href="#最佳实践">最佳实践</a>
      <ul>
        <li><a href="#目录结构">目录结构</a>
          <ul>
            <li><a href="#pkg">/pkg</a></li>
            <li><a href="#cmd">/cmd</a></li>
            <li><a href="#api">/api</a></li>
            <li><a href="#makefile">Makefile</a></li>
            <li><a href="#小结">小结</a></li>
          </ul>
        </li>
        <li><a href="#模块拆分">模块拆分</a>
          <ul>
            <li><a href="#按层拆分">按层拆分</a></li>
            <li><a href="#按职责拆分">按职责拆分</a></li>
            <li><a href="#小结-1">小结</a></li>
          </ul>
        </li>
        <li><a href="#显式与隐式">显式与隐式</a>
          <ul>
            <li><a href="#init">init</a></li>
            <li><a href="#error">error</a></li>
            <li><a href="#小结-2">小结</a></li>
          </ul>
        </li>
        <li><a href="#面向接口">面向接口</a></li>
        <li><a href="#小结-3">小结</a></li>
      </ul>
    </li>
    <li><a href="#单元测试">单元测试</a>
      <ul>
        <li><a href="#可测试">可测试</a>
          <ul>
            <li><a href="#接口">接口</a></li>
            <li><a href="#函数简单">函数简单</a></li>
          </ul>
        </li>
        <li><a href="#组织方式">组织方式</a>
          <ul>
            <li><a href="#test">Test</a></li>
            <li><a href="#suite">Suite</a></li>
            <li><a href="#bdd">BDD</a></li>
          </ul>
        </li>
        <li><a href="#mock-方法">Mock 方法</a>
          <ul>
            <li><a href="#接口-1">接口</a></li>
            <li><a href="#sql">SQL</a></li>
            <li><a href="#http">HTTP</a></li>
            <li><a href="#猴子补丁">猴子补丁</a></li>
          </ul>
        </li>
        <li><a href="#断言">断言</a></li>
        <li><a href="#小结-4">小结</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#reference">Reference</a></li>
    <li><a href="#推荐阅读">推荐阅读</a></li>
  </ul>
</nav>
                
                <hr>
                <p>[TOC]</p>
<h1 id="如何写出优雅的-go-语言代码">如何写出优雅的 Go 语言代码</h1>
<p>2019-05-30<a href="https://draveness.me/tags/golang">Golang</a><a href="https://draveness.me/tags/go">Go</a><a href="https://draveness.me/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">代码规范</a><a href="https://draveness.me/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a><a href="https://draveness.me/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a><a href="https://draveness.me/tags/%E6%8E%A5%E5%8F%A3">接口</a></p>
<p>Go 语言是一门简单、易学的编程语言，对于有编程背景的工程师来说，学习 Go  语言并写出能够运行的代码并不是一件困难的事情，对于之前有过其他语言经验的开发者来说，写什么语言都像自己学过的语言其实是有问题的，想要真正融入生态写出优雅的代码就一定要花一些时间和精力了解语言背后的设计哲学和最佳实践。</p>
<p>![bottle-of-wate](<a href="https://img.draveness.me/bottle-of-water.png">https://img.draveness.me/bottle-of-water.png</a></p>
<p>如果你之前没有 Go 语言的开发经历，正在学习和使用 Go 语言，相信这篇文章能够帮助你更快地写出优雅的 Go 语言代码；在这篇文章中，我们并不会给一个长长地列表介绍变量、方法和结构体应该怎么命名，这些 Go 语言的代码规范可以在 <a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a> 中找到，它们非常重要但并不是这篇文章想要介绍的重点，我们将从代码结构、最佳实践以及单元测试几个不同的方面介绍如何写出优雅的 Go 语言代码。</p>
<h2 id="写在前面">写在前面</h2>
<p>想要写出好的代码并不是一件容易的事情，它需要我们不断地对现有的代码进行反思 — 如何改写这段代码才能让它变得更加优雅。优雅听起来是一个非常感性、难以量化的结果，然而这却是好的代码能够带来的最直观感受，它可能隐式地包含了以下特性：</p>
<ul>
<li>容易阅读和理解；</li>
<li>容易测试、维护和扩展；</li>
<li>命名清晰、无歧义、注释完善清楚；</li>
<li>…</li>
</ul>
<p>相信读完了这篇文章，我们也不能立刻写出优雅的 Go 语言代码，但是如果我们遵循这里介绍几个的容易操作并且切实可行的方法，就帮助我们走出第一步，作者写这篇文章有以下的几个目的：</p>
<ul>
<li>帮助 Go 语言的开发者了解生态中的规范与工具，写出更优雅的代码；</li>
<li>为代码和项目的管理提供被社区广泛认同的规则、共识以及最佳实践；</li>
</ul>
<h2 id="代码规范">代码规范</h2>
<p>代码规范其实是一个老生常谈的问题，我们也不能免俗还是要简单介绍一下相关的内容，Go 语言比较常见并且使用广泛的代码规范就是官方提供的 <a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a>，无论你是短期还是长期使用 Go 语言编程，都应该<strong>至少完整地阅读一遍这个官方的代码规范指南</strong>，它既是我们在写代码时应该遵守的规则，也是在代码审查时需要注意的规范。</p>
<p>学习 Go 语言相关的代码规范是一件非常重要的事情，也是让我们的项目遵循统一规范的第一步，虽然阅读代码规范相关的文档非常重要，但是在实际操作时我们并不能靠工程师自觉地遵守以及经常被当做形式的代码审查，而是需要借助工具来辅助执行。</p>
<h3 id="辅助工具">辅助工具</h3>
<p>使用自动化的工具保证项目遵守一些最基本的代码规范是非常容易操作和有效的事情，相比之下人肉审查代码的方式更加容易出错，也会出现一些违反规则和约定的特例，维护代码规范的最好方式就是**『尽量自动化一切能够自动化的步骤，让工程师审查真正重要的逻辑和设计』**。</p>
<p>我们在这一节中就会介绍两种非常切实有效的办法帮助我们在项目中自动化地进行一些代码规范检查和静态检查保证项目的质量。</p>
<h4 id="goimports">goimports</h4>
<p><a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> 是 Go 语言官方提供的工具，它能够为我们自动格式化 Go 语言代码并对所有引入的包进行管理，包括自动增删依赖的包引用、将依赖包按字母序排序并分类。相信很多人使用的 IDE 都会将另一个官方提供的工具 <a href="https://golang.org/cmd/gofmt/">gofmt</a> 对代码进行格式化，而 <code>goimports</code> 就是等于 <code>gofmt</code> 加上依赖包管理。</p>
<p><img src="https://img.draveness.me/golang-goimports.png" alt="golang-goimports"></p>
<p>建议所有 Go 语言的开发者都在开发时使用 <code>goimports</code>，虽然 <code>goimports</code> 有时会引入错误的包，但是与带来的好处相比，这些偶尔出现的错误在作者看来也是可以接受的；当然，不想使用 <code>goimports</code> 的开发者也一定要在 IDE 或者编辑器中开启自动地 <code>gofmt</code>（保存时自动格式化）。</p>
<blockquote>
<p>在 IDE 和 CI 检查中开启自动地 <code>gofmt</code> 或者 <code>goimports</code> 检查是没有、也不应该有讨论的必要的，这就是一件使用和开发 Go 语言<strong>必须</strong>要做的事情。</p>
</blockquote>
<h4 id="golint">golint</h4>
<p>另一个比较常用的静态检查工具就是 <code>golint</code> 了，作为官方提供的工具，它在可定制化上有着非常差的支持，我们只能通过如下所示的方式运行 <code>golint</code> 对我们的项目进行检查：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash">$ golint ./pkg/...
pkg/liquidity/liquidity_pool.go:18:2: exported var ErrOrderBookNotFound should have comment or be unexported
pkg/liquidity/liquidity_pool.go:23:6: exported <span style="color:#366">type</span> LiquidityPool should have comment or be unexported
pkg/liquidity/liquidity_pool.go:23:6: <span style="color:#366">type</span> name will be used as liquidity.LiquidityPool by other packages, and that stutters; consider calling this Pool
pkg/liquidity/liquidity_pool.go:31:1: exported <span style="color:#069;font-weight:bold">function</span> NewLiquidityPool should have comment or be unexported
...
</code></pre></td></tr></table>
</div>
</div><p>社区上有关于 <code>golint</code> 定制化的 <a href="https://github.com/golang/lint/issues/263">讨论</a>，<code>golint</code> 的开发者给出了以下的几个观点解释为什么 <code>golint</code> 不支持定制化的功能：</p>
<blockquote>
<ul>
<li><code>lint</code> 的目的就是在 Go 语言社区中鼓励统一、一致的编程风格，某些开发者也许不会同意其中的某些规范，但是使用统一的风格对于 Go 语言社区有比较强的好处，而能够开关指定规则的功能会导致 <code>golint</code> 不能够有效地完成这个工作；</li>
<li>有一些静态检查的规则会导致一些错误的警告，这些情况确实非常让人头疼，但是我会选择支持在 golint 中直接保留或者删除这些规则，而不是提供随意增删规则的能力；</li>
<li>能够通过 <code>min_confidence</code> 过滤一些静态检查规则，但是需要我们选择合适的值；</li>
</ul>
</blockquote>
<p><code>golint</code> 作者的观点在 <a href="https://github.com/golang/lint/issues/263">issue</a> 中得到了非常多的 👎，但是这件事情很难说对错；在社区中保证一致的编程规范是一件非常有益的事情，不过对于很多公司内部的服务或者项目，可能在业务服务上就会发生一些比较棘手的情况，使用这种过强的约束没有太多明显地收益。</p>
<p><img src="https://img.draveness.me/golang-lint.png" alt="golang-lint"></p>
<p>更推荐的方法是在基础库或者框架中使用 <code>golint</code> 进行静态检查（或者同时使用 <code>golint</code> 和 <a href="https://github.com/golangci/golangci-lint">golangci-lint</a>），在其他的项目中使用可定制化的 <code>golangci-lint</code> 来进行静态检查，因为在基础库和框架中施加强限制对于整体的代码质量有着更大的收益。</p>
<blockquote>
<p>作者会在自己的 Go 项目中使用 <code>golint</code> + <code>golangci-lint</code> 并开启全部的检查尽量尽早发现代码中包含文档在内的全部缺陷。</p>
</blockquote>
<h3 id="自动化">自动化</h3>
<p>无论是用于检查代码规范和依赖包的 <code>goimports</code> 还是静态检查工具 <code>glint</code> 或者 <code>golangci-lint</code>，只要我们在项目中引入这些工具就一定要在代码的 CI 流程中加入对应的自动化检查：</p>
<ul>
<li>在 GitHub 上我们可以使用 <a href="https://travis-ci.org/">Travis CI</a> 或者 <a href="https://circleci.com/">CircleCI</a>；</li>
<li>在 Gitlab 上我们可以使用 <a href="https://about.gitlab.com/product/continuous-integration/">Gitlab CI</a>；</li>
</ul>
<p>在自建的或者其他的代码托管平台上也应该想尽办法寻找合适的工具，现代的代码托管工具应该都会对 CI/CD 有着非常不错的支持；我们需要通过这些 CI 工具将代码的自动化检查变成 PR 合并和发版的一个前置条件，减少工程师 Review 代码时可能发生的疏漏。</p>
<h2 id="最佳实践">最佳实践</h2>
<p>我们在上一节中介绍了一些能通过自动化工具发现的问题，这一节提到的最佳实践可能就没有办法通过自动化工具进行保证，这些最佳实践更像是 Go 语言社区内部发展过程中积累的一些工程经验和共识，遵循这些最佳实践能够帮助我们写出符合 Go  语言『味道』的代码，我们将在这一小节覆盖以下的几部分内容：</p>
<ul>
<li>目录结构；</li>
<li>模块拆分；</li>
<li>显式调用；</li>
<li>面向接口；</li>
</ul>
<p>这四部分内容是在社区中相对来说比较常见的约定，如果我们学习并遵循了这些约定，同时在 Go 语言的项目中实践这几部分内容，相信一定会对我们设计 Go 语言项目有所帮助。</p>
<h3 id="目录结构">目录结构</h3>
<p>目录结构基本上就是一个项目的门面，很多时候我们从目录结构中就能够看出开发者对这门语言是否有足够的经验，所以在这里首先要介绍的最佳实践就是如何在 Go 语言的项目或者服务中组织代码。</p>
<p>官方并没有给出一个推荐的目录划分方式，很多项目对于目录结构的划分也非常随意，这其实也是没有什么问题的，但是社区中还是有一些比较常见的约定，例如：<a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a> 项目中就定义了一个比较标准的目录结构。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash">├── LICENSE.md
├── Makefile
├── README.md
├── api
├── assets
├── build
├── cmd
├── configs
├── deployments
├── docs
├── examples
├── githooks
├── init
├── internal
├── pkg
├── scripts
├── <span style="color:#366">test</span>
├── third_party
├── tools
├── vendor
├── web
└── website
</code></pre></td></tr></table>
</div>
</div><p>我们在这里就先简单介绍其中几个比较常见并且重要的目录和文件，帮助我们快速理解如何使用如上所示的目录结构，如果各位读者想要了解使用其他目录的原因，可以从 <a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a> 项目中的 README 了解更详细的内容。</p>
<h4 id="pkg">/pkg</h4>
<p><code>/pkg</code> 目录是 Go 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影，例如：</p>
<ul>
<li><a href="https://github.com/prometheus/prometheus">prometheus</a> 上报和存储指标的时序数据库</li>
<li><a href="https://github.com/istio/istio">istio</a> 服务网格 2.0</li>
<li><a href="https://github.com/kubernetes/kubernetes">kubernetes</a> 容器调度管理系统</li>
<li><a href="https://github.com/grafana/grafana">grafana</a> 展示监控和指标的仪表盘</li>
</ul>
<p>这个目录中存放的就是项目中可以被外部应用使用的代码库，其他的项目可以直接通过 <code>import</code> 引入这里的代码，所以当我们将代码放入 <code>pkg</code> 时一定要慎重，不过如果我们开发的是 HTTP 或者 RPC 的接口服务或者公司的内部服务，将私有和公有的代码都放到 <code>/pkg</code> 中也没有太多的不妥，因为作为最顶层的项目来说很少会被其他应用直接依赖，当然严格遵循公有和私有代码划分是非常好的做法，作者也建议各位开发者对项目中公有和私有的代码进行妥善的划分。</p>
<h5 id="私有代码">私有代码</h5>
<p>私有代码推荐放到 <code>/internal</code> 目录中，真正的项目代码应该写在 <code>/internal/app</code> 里，同时这些内部应用依赖的代码库应该在 <code>/internal/pkg</code> 子目录和 <code>/pkg</code> 中，下图展示了一个使用 <code>/internal</code> 目录的项目结构：</p>
<p><img src="https://img.draveness.me/golang-internal-app-and-pkg.png" alt="golang-internal-app-and-pkg"></p>
<p>当我们在其他项目引入包含 <code>internal</code> 的依赖时，Go 语言会在编译时报错：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-text" data-lang="text">An import of a path containing the element “internal” is disallowed
if the importing code is outside the tree rooted at the parent of the 
&#34;internal&#34; directory.
</code></pre></td></tr></table>
</div>
</div><p>这种错误只有在被引入的 <code>internal</code> 包不存在于当前项目树中才会发生，如果在同一个项目中引入该项目的 <code>internal</code> 包并不会出现这种错误。</p>
<h5 id="src">/src</h5>
<p>在 Go 语言的项目最不应该有的目录结构其实就是 <code>/src</code> 了，社区中的一些项目确实有 <code>/src</code> 文件夹，但是这些项目的开发者之前大多数都有 Java 的编程经验，这在 Java 和其他语言中其实是一个比较常见的代码组织方式，但是作为一个 Go 语言的开发者，我们不应该允许项目中存在 <code>/src</code> 目录。</p>
<p>最重要的原因其实是 Go 语言的项目在默认情况下都会被放置到 <code>$GOPATH/src</code> 目录下，这个目录中存储着我们开发和依赖的全部项目代码，如果我们在自己的项目中使用 <code>/src</code> 目录，该项目的 <code>PATH</code> 中就会出现两个 <code>src</code>：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash"><span style="color:#033">$GOPATH</span>/src/github.com/draveness/project/src/code.go
</code></pre></td></tr></table>
</div>
</div><p>上面的目录结构看起来非常奇怪，这也是我们在 Go 语言中不建议使用 <code>/src</code> 目录的最重要原因。</p>
<p>当然哪怕我们在 Go 语言的项目中使用 <code>/src</code> 目录也不会导致编译不通过或者其他问题，如果坚持这种做法对于项目的可用性也没有任何的影响，但是如果想让我们『看起来』更专业，还是遵循社区中既定的约定减少其他 Go 语言开发者的理解成本，这对于社区来说是一件好事。</p>
<h5 id="平铺">平铺</h5>
<p>另一种在 Go 语言中组织代码的方式就是项目的根目录下放项目的代码，这种方式在很多框架或者库中非常常见，如果想要引入一个使用 <code>pkg</code> 目录结构的框架时，我们往往需要使用 <code>github.com/draveness/project/pkg/somepkg</code>，当代码都平铺在项目的根目录时只需要使用 <code>github.com/draveness/project</code>，很明显地减少了引用依赖包语句的长度。</p>
<p>所以对于一个 Go 语言的框架或者库，将代码平铺在根目录下也很正常，但是在一个 Go 语言的服务中使用这种代码组织方法可能就没有那么合适了。</p>
<h4 id="cmd">/cmd</h4>
<p><code>/cmd</code> 目录中存储的都是当前项目中的可执行文件，该目录下的每一个子目录都应该包含我们希望有的可执行文件，如果我们的项目是一个 <code>grpc</code> 服务的话，可能在 <code>/cmd/server/main.go</code> 中就包含了启动服务进程的代码，编译后生成的可执行文件就是 <code>server</code>。</p>
<p>我们不应该在 <code>/cmd</code> 目录中放置太多的代码，我们应该将公有代码放置到 <code>/pkg</code> 中并将私有代码放置到 <code>/internal</code> 中并在 <code>/cmd</code> 中引入这些包，保证 <code>main</code> 函数中的代码尽可能简单和少。</p>
<h4 id="api">/api</h4>
<p><code>/api</code> 目录中存放的就是当前项目对外提供的各种不同类型的 API 接口定义文件了，其中可能包含类似 <code>/api/protobuf-spec</code>、<code>/api/thrift-spec</code> 或者 <code>/api/http-spec</code> 的目录，这些目录中包含了当前项目对外提供的和依赖的所有 API 文件：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash">$ tree ./api
api
└── protobuf-spec
    └── oceanbookpb
        ├── oceanbook.pb.go
        └── oceanbook.proto
</code></pre></td></tr></table>
</div>
</div><p>二级目录的主要作用就是在一个项目同时提供了多种不同的访问方式时，用这种办法避免可能存在的潜在冲突问题，也可以让项目结构的组织更加清晰。</p>
<h4 id="makefile">Makefile</h4>
<p>最后要介绍的 <code>Makefile</code> 文件也非常值得被关注，在任何一个项目中都会存在一些需要运行的脚本，这些脚本文件应该被放到 <code>/scripts</code> 目录中并由 <code>Makefile</code> 触发，将这些经常需要运行的命令固化成脚本减少『祖传命令』的出现。</p>
<h4 id="小结">小结</h4>
<p>总的来说，每一个项目都应该按照固定的组织方式进行实现，这种约定虽然并不是强制的，但是无论是组内、公司内还是整个 Go 语言社区中，只要达成了一致，对于其他工程师快速梳理和理解项目都是很有帮助的。</p>
<p>这一节介绍的 Go 语言项目的组织方式也并不是强制要求的，这只是 Go 语言社区中经常出现的项目组织方式，一个大型项目在使用这种目录结构时也会对其进行微调，不过这种组织方式确实更为常见并且合理。</p>
<h3 id="模块拆分">模块拆分</h3>
<p>我们既然已经介绍过了如何从顶层对项目的结构进行组织，接下来就会深入到项目的内部介绍 Go 语言对模块的一些拆分方法。</p>
<p>Go 语言的一些顶层设计最终导致了它在划分模块上与其他的编程语言有着非常明显的不同，很多其他语言的 Web 框架都采用 MVC 的架构模式，例如 Rails 和 Spring MVC，Go 语言对模块划分的方法就与 Ruby 和 Java 完全不同。</p>
<h4 id="按层拆分">按层拆分</h4>
<p>无论是 Java 还是 Ruby，它们最著名的框架都深受 <a href="https://draveness.me/mvx">MVC 架构模式</a> 的影响，我们从 Spring MVC 的名字中就能体会到 MVC 对它的影响，而 Ruby 社区的 Rails 框架也与 MVC  的关系非常紧密，这是一种 Web 框架的最常见架构方式，将服务中的不同组件分成了 Model、View 和 Controller 三层。</p>
<p><img src="https://img.draveness.me/divide-by-layer.jpg" alt="divide-by-laye"></p>
<p>这种模块拆分的方式其实就是按照层级进行拆分，Rails 脚手架默认生成的代码其实就是将这三层不同的源文件放在对应的目录下：<code>models</code>、<code>views</code> 和 <code>controllers</code>，我们通过 <code>rails new example</code> 生成一个新的 Rails 项目后可以看到其中的目录结构：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#a00;background-color:#faa">$</span> tree <span style="color:#555">-</span>L <span style="color:#f60">2</span> app
app
<span style="color:#a00;background-color:#faa">├──</span> controllers
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">├──</span> application_controller.rb
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">└──</span> concerns
<span style="color:#a00;background-color:#faa">├──</span> models
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">├──</span> application_record.rb
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">└──</span> concerns
<span style="color:#a00;background-color:#faa">└──</span> views
    <span style="color:#a00;background-color:#faa">└──</span> layouts
</code></pre></td></tr></table>
</div>
</div><p>而很多 Spring MVC 的项目中也会出现类似 <code>model</code>、<code>dao</code>、<code>view</code> 的目录，这种按层拆分模块的设计其实有以下的几方面原因：</p>
<ol>
<li>MVC 架构模式 — MVC 本身就强调了按层划分职责的设计，所以遵循该模式设计的框架自然有着一脉相承的思路；</li>
<li>扁平的命名空间 — 无论是 Spring MVC 还是 Rails，同一个项目中命名空间非常扁平，跨文件夹使用其他文件夹中定义的类或者方法不需要引入新的包，使用其他文件定义的类时也不需要增加额外的前缀，多个文件定义的类被『合并』到了同一个命名空间中；</li>
<li>单体服务的场景 — Spring MVC 和 Rails 刚出现时，SOA 和微服务架构还不像今天这么普遍，绝大多数的场景也不需要通过拆分服务；</li>
</ol>
<p>上面的几个原因共同决定了 Spring MVC 和 Rails 会出现 <code>models</code>、<code>views</code> 和 <code>controllers</code> 的目录并按照层级的方式对模块进行拆分。</p>
<h4 id="按职责拆分">按职责拆分</h4>
<p>Go 语言在拆分模块时就使用了完全不同的思路，虽然 MVC 架构模式是在我们写 Web 服务时无法避开的，但是相比于横向地切分不同的层级，Go 语言的项目往往都按照职责对模块进行拆分：</p>
<p><img src="https://img.draveness.me/divide-by-responsibility.jpg" alt="divide-by-responsibility"></p>
<p>对于一个比较常见的博客系统，使用 Go 语言的项目会按照不同的职责将其纵向拆分成 <code>post</code>、<code>user</code>、<code>comment</code> 三个模块，每一个模块都对外提供相应的功能，<code>post</code> 模块中就包含相关的模型和视图定义以及用于处理 API 请求的控制器（或者服务）：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#a00;background-color:#faa">$</span> tree pkg
pkg
<span style="color:#a00;background-color:#faa">├──</span> comment
<span style="color:#a00;background-color:#faa">├──</span> post
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">├──</span> handler.<span style="color:#069;font-weight:bold">go</span>
<span style="color:#a00;background-color:#faa">│</span>   <span style="color:#a00;background-color:#faa">└──</span> post.<span style="color:#069;font-weight:bold">go</span>
<span style="color:#a00;background-color:#faa">└──</span> user
</code></pre></td></tr></table>
</div>
</div><p>Go 语言项目中的每一个文件目录都代表着一个<strong>独立的命名空间</strong>，也就是一个单独的包，当我们想要引用其他文件夹的目录时，首先需要使用 <code>import</code> 关键字引入相应的文件目录，再通过 <code>pkg.xxx</code> 的形式引用其他目录定义的结构体、函数或者常量，如果我们在 Go 语言中使用 <code>model</code>、<code>view</code> 和 <code>controller</code> 来划分层级，你会在其他的模块中看到非常多的 <code>model.Post</code>、<code>model.Comment</code> 和 <code>view.PostView</code>。</p>
<p>这种划分层级的方法在 Go 语言中会显得非常冗余，并且如果对项目依赖包的管理不够谨慎时，很容易发生引用循环，出现这些问题的最根本原因其实也非常简单：</p>
<ol>
<li>Go 语言对同一个项目中不同目录的命名空间做了隔离，整个项目中定义的类和方法并不是在同一个命名空间下的，这也就需要工程师自己维护不同包之间的依赖关系；</li>
<li>按照职责垂直拆分的方式在单体服务遇到瓶颈时非常容易对微服务进行拆分，我们可以直接将一个负责独立功能的 <code>package</code> 拆出去，对这部分性能热点单独进行扩容；</li>
</ol>
<h4 id="小结-1">小结</h4>
<p>项目是按照层级还是按照职责对模块进行拆分其实并没有绝对的好与不好，语言和框架层面的设计最终决定了我们应该采用哪种方式对项目和代码进行组织。</p>
<p>Java 和 Ruby 这些语言在框架中往往采用水平拆分的方式划分不同层级的职责，而 Go 语言项目的最佳实践就是按照职责对模块进行垂直拆分，将代码按照功能的方式分到多个 <code>package</code> 中，这并不是说 Go 语言中不存在模块的水平拆分，只是因为 <code>package</code> 作为一个 Go 语言访问控制的最小粒度，所以我们应该遵循顶层的设计使用这种方式构建高内聚的模块。</p>
<h3 id="显式与隐式">显式与隐式</h3>
<p>从开始学习、使用 Go 语言到参与社区上一些开源的 Go 语言项目，作者发现 Go 语言社区对于<strong>显式的初始化、方法调用和错误处理</strong>非常推崇，类似 Spring Boot 和 Rails 的框架其实都广泛地采纳了『约定优于配置』的中心思想，简化了开发者和工程师的工作量。</p>
<p>然而 Go 语言社区虽然达成了很多的共识与约定，但是从语言的设计以及工具上的使用我们就能发现显式地调用方法和错误处理是被鼓励的。</p>
<h4 id="init">init</h4>
<p>我们在这里先以一个非常常见的函数 <code>init</code> 为例，介绍 Go 语言社区对显式调用的推崇；相信很多人都在一些 <code>package</code> 中阅读过这样的代码：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">var</span> grpcClient <span style="color:#555">*</span>grpc.Client

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">init</span>() {
    <span style="color:#069;font-weight:bold">var</span> err <span style="color:#078;font-weight:bold">error</span>
    grpcClient, err = grpc.<span style="color:#c0f">Dial</span>(<span style="color:#555">...</span>)
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#366">panic</span>(err)
    }
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">GetPost</span>(postID <span style="color:#078;font-weight:bold">int64</span>) (<span style="color:#555">*</span>Post, <span style="color:#078;font-weight:bold">error</span>) {
    post, err <span style="color:#555">:=</span> grpcClient.<span style="color:#c0f">FindPost</span>(context.<span style="color:#c0f">Background</span>(), <span style="color:#555">&amp;</span>pb.FindPostRequest{PostID: postID})
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> <span style="color:#069;font-weight:bold">nil</span>, err
    }
    
    <span style="color:#069;font-weight:bold">return</span> post, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><p>这种代码虽然能够通过编译并且正常工作，然而这里的 <code>init</code> 函数其实隐式地初始化了 grpc 的连接资源，如果另一个 <code>package</code> 依赖了当前的包，那么引入这个依赖的工程师可能会在遇到错误时非常困惑，因为在 <code>init</code> 函数中做这种资源的初始化是非常耗时并且容易出现问题的。</p>
<p>一种更加合理的做法其实是这样的，首先我们定义一个新的 <code>Client</code> 结构体以及一个用于初始化结构的 <code>NewClient</code> 函数，这个函数接收了一个 grpc 连接作为入参返回一个用于获取 <code>Post</code> 资源的客户端，<code>GetPost</code> 成为了这个结构体的方法，每当我们调用 <code>client.GetPost</code> 时都会用到结构体中保存的 grpc 连接：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// pkg/post/client.go
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">type</span> Client <span style="color:#069;font-weight:bold">struct</span> {
    grpcClient <span style="color:#555">*</span>grpc.ClientConn    
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">NewClient</span>(grpcClient <span style="color:#555">*</span>grpcClientConn) Client {
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#555">&amp;</span>Client{
        grpcClient: grpcClient,
    }
}

<span style="color:#069;font-weight:bold">func</span> (c <span style="color:#555">*</span>Client) <span style="color:#c0f">GetPost</span>(postID <span style="color:#078;font-weight:bold">int64</span>) (<span style="color:#555">*</span>Post, <span style="color:#078;font-weight:bold">error</span>) {
    post, err <span style="color:#555">:=</span> c.grpcClient.<span style="color:#c0f">FindPost</span>(context.<span style="color:#c0f">Background</span>(), <span style="color:#555">&amp;</span>pb.FindPostRequest{PostID: postID})
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> <span style="color:#069;font-weight:bold">nil</span>, err
    }
    
    <span style="color:#069;font-weight:bold">return</span> post, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><p>初始化 grpc 连接的代码应该放到 <code>main</code> 函数或者 <code>main</code> 函数调用的其他函数中执行，如果我们在 <code>main</code> 函数中显式的初始化这种依赖，对于其他的工程师来说就非常易于理解，我们从 <code>main</code> 函数开始就能梳理出程序启动的整个过程。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#09f;font-style:italic">// cmd/grpc/main.go
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
    grpcClient, err <span style="color:#555">:=</span> grpc.<span style="color:#c0f">Dial</span>(<span style="color:#555">...</span>)
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#366">panic</span>(err)
    }
    
    postClient <span style="color:#555">:=</span> post.<span style="color:#c0f">NewClient</span>(grpcClient)
    <span style="color:#09f;font-style:italic">// ...
</span><span style="color:#09f;font-style:italic"></span>}
</code></pre></td></tr></table>
</div>
</div><p>各个模块之间会构成一种树形的结构和依赖关系，上层的模块会持有下层模块中的接口或者结构体，不会存在孤立的、不被引用的对象。</p>
<p><img src="https://img.draveness.me/golang-project-and-tree-structure.jpg" alt="golang-project-and-tree-structure"></p>
<blockquote>
<p>上图中出现的两个 <code>Database</code> 其实是在 <code>main</code> 函数中初始化的数据库连接，在项目运行期间，它们可能表示同一个内存中的数据库连接</p>
</blockquote>
<p>当我们使用 <a href="https://github.com/golangci/golangci-lint">golangci-lint</a> 并开启 <code>gochecknoinits</code> 和 <code>gochecknoglobals</code> 静态检查时，它其实严格地限制我们对 <code>init</code> 函数和全局变量的使用。</p>
<p>当然这并不是说我们一定不能使用 <code>init</code> 函数，作为 Go 语言赋予开发者的能力，因为它能在包被引入时隐式地执行了一些代码，所以我们更应该慎重地使用它们。</p>
<p>一些框架会在 <code>init</code> 中判断是否满足使用的前置条件，但是对于很多的 Web 或者 API 服务来说，大量使用 <code>init</code> 往往意味着代码质量的下降以及不合理的设计。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">init</span>() {
    <span style="color:#069;font-weight:bold">if</span> user <span style="color:#555">==</span> <span style="color:#c30">&#34;&#34;</span> {
        log.<span style="color:#c0f">Fatal</span>(<span style="color:#c30">&#34;$USER not set&#34;</span>)
    }
    <span style="color:#069;font-weight:bold">if</span> home <span style="color:#555">==</span> <span style="color:#c30">&#34;&#34;</span> {
        home = <span style="color:#c30">&#34;/home/&#34;</span> <span style="color:#555">+</span> user
    }
    <span style="color:#069;font-weight:bold">if</span> gopath <span style="color:#555">==</span> <span style="color:#c30">&#34;&#34;</span> {
        gopath = home <span style="color:#555">+</span> <span style="color:#c30">&#34;/go&#34;</span>
    }
    <span style="color:#09f;font-style:italic">// gopath may be overridden by --gopath flag on command line.
</span><span style="color:#09f;font-style:italic"></span>    flag.<span style="color:#c0f">StringVar</span>(<span style="color:#555">&amp;</span>gopath, <span style="color:#c30">&#34;gopath&#34;</span>, gopath, <span style="color:#c30">&#34;override default GOPATH&#34;</span>)
}
</code></pre></td></tr></table>
</div>
</div><p>上述代码其实是 <a href="https://golang.org/doc/effective_go.html#init">Effective Go</a> 在介绍 <code>init</code> 方法使用是展示的实例代码，这是一个比较合理地 <code>init</code> 函数使用示例，我们不应该在 <code>init</code> 中做过重的初始化逻辑，而是做一些简单、轻量的前置条件判断。</p>
<h4 id="error">error</h4>
<p>另一个要介绍的就是 Go 语言的错误处理机制了，虽然 Go 语言的错误处理被开发者诟病已久，但是工程师每天都在写 <code>if err != nil { return nil, err }</code> 的错误处理逻辑其实就是在显式地对错误处理，关注所有可能会发生错误的方法调用并在无法处理时抛给上层模块。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">ListPosts</span>(<span style="color:#555">...</span>) ([]Post, <span style="color:#078;font-weight:bold">error</span>) {
    conn, err <span style="color:#555">:=</span> gorm.<span style="color:#c0f">Open</span>(<span style="color:#555">...</span>)
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> []Post{}, err
    }
    
    <span style="color:#069;font-weight:bold">var</span> posts []Post
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">:=</span> conn.<span style="color:#c0f">Find</span>(<span style="color:#555">&amp;</span>posts).Error; err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> []Post{}, err
    }
    
    <span style="color:#069;font-weight:bold">return</span> posts, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>上述代码只是简单展示 Go 语言常见的错误处理逻辑，我们<strong>不应该</strong>在这种方法中初始化数据库的连接。</p>
</blockquote>
<p>虽然 Go 语言中也有类似 Java 或者 Ruby <code>try/catch</code> 关键字，但是很少有人会在代码中使用 <code>panic</code> 和 <code>recover</code> 来实现错误和异常的处理，与 <code>init</code> 函数一样，Go 语言对于 <code>panic</code> 和 <code>recover</code> 的使用也非常谨慎。</p>
<p>当我们在 Go 语言中处理错误相关的逻辑时，最重要的其实就是以下几点：</p>
<ol>
<li><strong>使用 <code>error</code> 实现错误处理</strong> — 尽管这看起来非常啰嗦；</li>
<li><strong>将错误抛给上层处理</strong> — 对于一个方法是否需要返回 <code>error</code> 也需要我们仔细地思考，向上抛出错误时可以通过 <code>errors.Wrap</code> 携带一些额外的信息方便上层进行判断；</li>
<li><strong>处理所有可能返回的错误</strong> — 所有可能返回错误的地方最终一定会返回错误，考虑全面才能帮助我们构建更加健壮的项目；</li>
</ol>
<h4 id="小结-2">小结</h4>
<p>作者在使用 Go 语言的这段时间，能够深刻地体会到它对于显式方法调用与错误处理的鼓励，这不仅能够帮助项目的其他开发者快速地理解上下文，也能够帮助我们构建更加健壮、容错性与可维护性更好的工程。</p>
<h3 id="面向接口">面向接口</h3>
<p>面向接口编程是一个老生常谈的话题，<a href="https://draveness.me/golang-interface">接口</a> 的作用其实就是为不同层级的模块提供了一个定义好的中间层，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦。</p>
<p><img src="https://img.draveness.me/golang-interface.png" alt="golang-interface"></p>
<p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式，它为我们的程序提供了非常强的灵活性，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p>
<p>如果一个略有规模的项目中没有出现任何 <code>type ... interface</code> 的定义，那么作者可以推测出这在很大的概率上是一个<strong>工程质量堪忧并且没有多少单元测试覆盖</strong>的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。</p>
<blockquote>
<p>单元测试是一个项目保证工程质量最有效并且投资回报率最高的方法之一，作为静态语言的 Go，想要写出覆盖率足够（最少覆盖核心逻辑）的单元测试本身就比较困难，因为我们不能像动态语言一样<strong>随意</strong>修改函数和方法的行为，而接口就成了我们的救命稻草，写出抽象良好的接口并通过接口隔离依赖能够帮助我们有效地提升项目的质量和可测试性，我们会在下一节中详细介绍如何写单元测试。</p>
</blockquote>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> post

<span style="color:#069;font-weight:bold">var</span> client <span style="color:#555">*</span>grpc.ClientConn

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">init</span>() {
    <span style="color:#069;font-weight:bold">var</span> err <span style="color:#078;font-weight:bold">error</span>
    client, err = grpc.<span style="color:#c0f">Dial</span>(<span style="color:#555">...</span><span style="color:#a00;background-color:#faa">）</span>
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#366">panic</span>(err)
    }
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">ListPosts</span>() ([]<span style="color:#555">*</span>Post, <span style="color:#078;font-weight:bold">error</span>) {
    posts, err <span style="color:#555">:=</span> client.<span style="color:#c0f">ListPosts</span>(<span style="color:#555">...</span>)
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> []<span style="color:#555">*</span>Post{}, err
    }
    
    <span style="color:#069;font-weight:bold">return</span> posts, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><p>上述代码其实就不是一个设计良好的代码，它不仅在 <code>init</code> 函数中隐式地初始化了 grpc 连接这种全局变量，而且没有将 <code>ListPosts</code> 通过接口的方式暴露出去，这会让依赖 <code>ListPosts</code> 的上层模块难以测试。</p>
<p>我们可以使用下面的代码改写原有的逻辑，使得同样地逻辑变得更容易测试和维护：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> post

<span style="color:#069;font-weight:bold">type</span> Service <span style="color:#069;font-weight:bold">interface</span> {
    <span style="color:#c0f">ListPosts</span>() ([]<span style="color:#555">*</span>Post, <span style="color:#078;font-weight:bold">error</span>)
}

<span style="color:#069;font-weight:bold">type</span> service <span style="color:#069;font-weight:bold">struct</span> {
    conn <span style="color:#555">*</span>grpc.ClientConn
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">NewService</span>(conn <span style="color:#555">*</span>grpc.ClientConn) Service {
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#555">&amp;</span>service{
        conn: conn,
    }
}

<span style="color:#069;font-weight:bold">func</span> (s <span style="color:#555">*</span>service) <span style="color:#c0f">ListPosts</span>() ([]<span style="color:#555">*</span>Post, <span style="color:#078;font-weight:bold">error</span>) {
    posts, err <span style="color:#555">:=</span> s.conn.<span style="color:#c0f">ListPosts</span>(<span style="color:#555">...</span>)
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#069;font-weight:bold">return</span> []<span style="color:#555">*</span>Post{}, err
    }
    
    <span style="color:#069;font-weight:bold">return</span> posts, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><ol>
<li>通过接口 <code>Service</code> 暴露对外的 <code>ListPosts</code> 方法；</li>
<li>使用 <code>NewService</code> 函数初始化 <code>Service</code> 接口的实现并通过私有的结构体 <code>service</code> 持有 grpc 连接；</li>
<li><code>ListPosts</code> 不再依赖全局变量，而是依赖接口体 <code>service</code> 持有的连接；</li>
</ol>
<p>当我们使用这种方式重构代码之后，就可以在 <code>main</code> 函数中显式的初始化 grpc 连接、创建 <code>Service</code> 接口的实现并调用 <code>ListPosts</code> 方法：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> main

<span style="color:#069;font-weight:bold">import</span> <span style="color:#555">...</span>

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
    conn, err = grpc.<span style="color:#c0f">Dial</span>(<span style="color:#555">...</span><span style="color:#a00;background-color:#faa">）</span>
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#366">panic</span>(err)
    }
    
    svc <span style="color:#555">:=</span> post.<span style="color:#c0f">NewService</span>(conn)
    posts, err <span style="color:#555">:=</span> svc.<span style="color:#c0f">ListPosts</span>()
    <span style="color:#069;font-weight:bold">if</span> err <span style="color:#555">!=</span> <span style="color:#069;font-weight:bold">nil</span> {
        <span style="color:#366">panic</span>(err)
    }
    
    fmt.<span style="color:#c0f">Println</span>(posts)
}
</code></pre></td></tr></table>
</div>
</div><p>这种使用接口组织代码的方式在 Go 语言中非常常见，我们应该在代码中尽可能地使用这种思想和模式对外提供功能：</p>
<ol>
<li>使用大写的 <code>Service</code> 对外暴露方法；</li>
<li>使用小写的 <code>service</code> 实现接口中定义的方法；</li>
<li>通过 <code>NewService</code> 函数初始化 <code>Service</code> 接口；</li>
</ol>
<p>当我们使用上述方法组织代码之后，其实就对不同模块的依赖进行了解耦，也正遵循了软件设计中经常被提到的一句话 — 『依赖接口，不要依赖实现』，也就是<strong>面向接口编程</strong>。</p>
<h3 id="小结-3">小结</h3>
<p>在这一小节中总共介绍了 Go 语言中三个经常会打交道的『元素』— <code>init</code> 函数、<code>error</code> 和接口，我们在这里主要是想通过三个不同的例子为大家传达的一个主要思想就是尽量使用<strong>显式的（explicit）的方式</strong>编写 Go 语言代码。</p>
<h2 id="单元测试">单元测试</h2>
<p>一个代码质量和工程质量有保证的项目一定有比较合理的单元测试覆盖率，没有单元测试的项目一定是不合格的或者不重要的，单元测试应该是所有项目都必须有的代码，每一个单元测试都表示一个可能发生的情况，<strong>单元测试就是业务逻辑</strong>。</p>
<p>作为软件工程师，重构现有的项目对于我们来说应该是一件比较正常的事情，如果项目中没有单元测试，我们很难在不改变已有业务逻辑的情况对项目进行重构，一些业务的边界情况很可能会在重构的过程中丢失，当时参与相应 <code>case</code> 开发的工程师可能已经不在团队中，而项目相关的文档可能也消失在了归档的 <code>wiki</code> 中（更多的项目可能完全没有文档），我们能够在重构中相信的东西其实只有当前的代码逻辑（很可能是错误的）以及单元测试（很可能是没有的）。</p>
<p>简单总结一下，单元测试的缺失不仅会意味着较低的工程质量，而且意味着重构的难以进行，一个有单元测试的项目尚且不能够保证重构前后的逻辑完全相同，一个没有单元测试的项目很可能本身的项目质量就堪忧，更不用说<strong>如何在不丢失业务逻辑的情况下进行重构了</strong>。</p>
<h3 id="可测试">可测试</h3>
<p>写代码并不是一件多困难的事情，不过想要在项目中写出可以测试的代码并不容易，而优雅的代码一定是可以测试的，我们在这一节中需要讨论的就是什么样的代码是可以测试的。</p>
<p>如果想要想清楚什么样的才是可测试的，我们首先要知道测试是什么？作者对于测试的理解就是控制变量，在我们隔离了待测试方法中一些依赖之后，当函数的入参确定时，就应该得到期望的返回值。</p>
<p><img src="https://img.draveness.me/golang-unit-test.png" alt="golang-unit-test"></p>
<p>如何控制待测试方法中依赖的模块是写单元测试时至关重要的，控制依赖也就是对目标函数的依赖进行 <code>Mock</code> 消灭不确定性，为了减少每一个单元测试的复杂度，我们需要：</p>
<ol>
<li>尽可能减少目标方法的依赖，让目标方法只依赖必要的模块；</li>
<li>依赖的模块也应该非常容易地进行 <code>Mock</code>；</li>
</ol>
<p>单元测试的执行不应该依赖于任何的外部模块，无论是调用外部的 HTTP 请求还是数据库中的数据，我们都应该想尽办法模拟可能出现的情况，因为单元测试不是集成测试的，它的运行不应该依赖除项目代码外的其他任何系统。</p>
<h4 id="接口">接口</h4>
<p>在 Go 语言中如果我们完全不使用接口，是写不出易于测试的代码的，作为静态语言的 Go，只有我们使用接口才能脱离依赖具体实现的窘境，接口的使用能够为我们带来更清晰的抽象，帮助我们思考如何对代码进行设计，也能让我们更方便地对依赖进行 <code>Mock</code>。</p>
<p>我们再来回顾一下上一节对接口进行介绍时展示的常见模式：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">type</span> Service <span style="color:#069;font-weight:bold">interface</span> { <span style="color:#555">...</span> }

<span style="color:#069;font-weight:bold">type</span> service <span style="color:#069;font-weight:bold">struct</span> { <span style="color:#555">...</span> }

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">NewService</span>(<span style="color:#555">...</span>) (Service, <span style="color:#078;font-weight:bold">error</span>) {
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#555">&amp;</span>service{<span style="color:#555">...</span>}, <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><p>上述代码在 Go 语言中是非常常见的，如果你不知道应不应该使用接口对外提供服务，这时就应该无脑地使用上述模式对外暴露方法了，这种模式可以在绝大多数的场景下工作，至少作者到目前还没有见到过不适用的。</p>
<h4 id="函数简单">函数简单</h4>
<p>另一个建议就是保证每一个函数尽可能简单，这里的简单不止是指功能上的简单、单一，还意味着函数容易理解并且命名能够自解释。</p>
<p>一些语言的 <code>lint</code> 工具其实会对函数的理解复杂度（PerceivedComplexity）进行检查，也就是检查函数中出现的 <code>if/else</code>、<code>switch/case</code> 分支以及方法的调用的数量，一旦超过约定的阈值就会报错，Ruby 社区中的 Rubocop 和上面提到的 golangci-lint 都有这个功能。</p>
<p>Ruby 社区中的 Rubocop 对于函数的长度和理解复杂度都有着非常严格的限制，在默认情况下函数的行数不能超过 <code>10</code> 行，理解复杂度也不能超过 <code>7</code>，除此之外，Rubocop 其实还有其他的复杂度限制，例如循环复杂度（CyclomaticComplexity），这些复杂度的限制都是为了保证函数的简单和容易理解。</p>
<h3 id="组织方式">组织方式</h3>
<p>如何对测试进行组织也是一个值得讨论的话题，Go 语言中的单元测试文件和代码都是与源代码放在同一个目录下按照 <code>package</code> 进行组织的，<code>server.go</code> 文件对应的测试代码应该放在同一目录下的 <code>server_test.go</code> 文件中。</p>
<p>如果文件不是以 <code>_test.go</code> 结尾，当我们运行 <code>go test ./pkg</code> 时就不会找到该文件中的测试用例，其中的代码也就不会被执行，这也是 Go 语言对于测试组织方法的一个约定。</p>
<h4 id="test">Test</h4>
<p>单元测试的最常见以及默认组织方式就是写在以 <code>_test.go</code> 结尾的文件中，所有的测试方法也都是以 <code>Test</code> 开头并且只接受一个 <code>testing.T</code> 类型的参数：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestAuthor</span>(t <span style="color:#555">*</span>testing.T) {
    author <span style="color:#555">:=</span> blog.<span style="color:#c0f">Author</span>()
    assert.<span style="color:#c0f">Equal</span>(t, <span style="color:#c30">&#34;draveness&#34;</span>, author)
}
</code></pre></td></tr></table>
</div>
</div><p>如果我们要给函数名为 <code>Add</code> 的方法写单元测试，那么对应的测试方法一般会被写成 <code>TestAdd</code>，为了同时测试多个分支的内容，我们可以通过以下的方式组织 <code>Add</code> 函数相关的测试：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestAdd</span>(t <span style="color:#555">*</span>testing.T) {
    assert.<span style="color:#c0f">Equal</span>(t, <span style="color:#f60">5</span>, <span style="color:#c0f">Add</span>(<span style="color:#f60">2</span>, <span style="color:#f60">3</span>))
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestAddWithNegativeNumber</span>(t <span style="color:#555">*</span>testing.T) {
    assert.<span style="color:#c0f">Equal</span>(t, <span style="color:#555">-</span><span style="color:#f60">2</span>, <span style="color:#c0f">Add</span>(<span style="color:#555">-</span><span style="color:#f60">1</span>, <span style="color:#555">-</span><span style="color:#f60">1</span>))
}
</code></pre></td></tr></table>
</div>
</div><p>除了这种将一个函数相关的测试分散到多个 <code>Test</code> 方法之外，我们可以使用 <code>for</code> 循环来减少重复的测试代码，这在逻辑比较复杂的测试中会非常好用，能够减少大量的重复代码，不过也需要我们小心地进行设计：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestAdd</span>(t <span style="color:#555">*</span>testing.T) {
    tests <span style="color:#555">:=</span> []<span style="color:#069;font-weight:bold">struct</span>{
        name     <span style="color:#078;font-weight:bold">string</span>
        first    <span style="color:#078;font-weight:bold">int64</span>
        second   <span style="color:#078;font-weight:bold">int64</span>
        expected <span style="color:#078;font-weight:bold">int64</span>
    } {
        {
            name:     <span style="color:#c30">&#34;HappyPath&#34;</span>:
            first:    <span style="color:#f60">2</span>,
            second:   <span style="color:#f60">3</span>,
            expected: <span style="color:#f60">5</span>,
        },
        {
            name:     <span style="color:#c30">&#34;NegativeNumber&#34;</span>:
            first:    <span style="color:#555">-</span><span style="color:#f60">1</span>,
            second:   <span style="color:#555">-</span><span style="color:#f60">1</span>,
            expected: <span style="color:#555">-</span><span style="color:#f60">2</span>,
        },
    }
    
    <span style="color:#069;font-weight:bold">for</span> _, test <span style="color:#555">:=</span> <span style="color:#069;font-weight:bold">range</span> tests {
        t.<span style="color:#c0f">Run</span>(test.name, <span style="color:#069;font-weight:bold">func</span>(t <span style="color:#555">*</span>testing.T) {
            assert.<span style="color:#c0f">Equal</span>(t, test.expected, <span style="color:#c0f">Add</span>(test.first, test.second))
        })
    }
}
</code></pre></td></tr></table>
</div>
</div><p>这种方式其实也能生成树形的测试结果，将 <code>Add</code> 相关的测试分成一组方便我们进行观察和理解，不过这种测试组织方法需要我们保证测试代码的通用性，当函数依赖的上下文较多时往往需要我们写很多的 <code>if/else</code> 条件判断语句影响我们对测试的快速理解。</p>
<p>作者通常会在测试代码比较简单时使用第一种组织方式，而在依赖较多、函数功能较为复杂时使用第二种方式，不过这也不是定论，我们需要根据实际情况决定如何对测试进行设计。</p>
<h4 id="suite">Suite</h4>
<p>第二种比较常见的方式是按照簇进行组织，其实就是对 Go 语言默认的测试方式进行简单的封装，我们可以使用 <a href="https://github.com/stretchr/testify">stretchr/testify</a> 中的 <code>suite</code> 包对测试进行组织：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">import</span> (
    <span style="color:#c30">&#34;testing&#34;</span>
    <span style="color:#c30">&#34;github.com/stretchr/testify/suite&#34;</span>
)

<span style="color:#069;font-weight:bold">type</span> ExampleTestSuite <span style="color:#069;font-weight:bold">struct</span> {
    suite.Suite
    VariableThatShouldStartAtFive <span style="color:#078;font-weight:bold">int</span>
}

<span style="color:#069;font-weight:bold">func</span> (suite <span style="color:#555">*</span>ExampleTestSuite) <span style="color:#c0f">SetupTest</span>() {
    suite.VariableThatShouldStartAtFive = <span style="color:#f60">5</span>
}

<span style="color:#069;font-weight:bold">func</span> (suite <span style="color:#555">*</span>ExampleTestSuite) <span style="color:#c0f">TestExample</span>() {
    suite.<span style="color:#c0f">Equal</span>(suite.VariableThatShouldStartAtFive, <span style="color:#f60">5</span>)
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestExampleTestSuite</span>(t <span style="color:#555">*</span>testing.T) {
    suite.<span style="color:#c0f">Run</span>(t, <span style="color:#366">new</span>(ExampleTestSuite))
}
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用 <code>suite</code> 包，以结构体的方式对测试簇进行组织，<code>suite</code> 提供的 <code>SetupTest</code>/<code>SetupSuite</code> 和 <code>TearDownTest</code>/<code>TearDownSuite</code> 是执行测试前后以及执行测试簇前后的钩子方法，我们能在其中完成一些共享资源的初始化，减少测试中的初始化代码。</p>
<h4 id="bdd">BDD</h4>
<p>最后一种组织代码的方式就是使用 BDD 的风格对单元测试进行组织，<a href="https://github.com/onsi/ginkgo">ginkgo</a> 就是 Go 语言社区最常见的 BDD  框架了，这里提到的行为驱动开发（BDD）和测试驱动开发（TDD）都是一种保证工程质量的方法论。想要在项目中实践这种思想还是需要一些思维上的转变和适应，也就是先通过写单元测试或者行为测试约定方法的 Spec，再实现方法让我们的测试通过，这是一种比较科学的方法，它能为我们带来比较强的信心。</p>
<p>我们虽然不一定要使用 BDD/TDD 的思想对项目进行开发，但是却可以<strong>使用 BDD 的风格方式</strong>组织非常易读的测试代码：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">var</span> _ = <span style="color:#c0f">Describe</span>(<span style="color:#c30">&#34;Book&#34;</span>, <span style="color:#069;font-weight:bold">func</span>() {
    <span style="color:#069;font-weight:bold">var</span> (
        book Book
        err <span style="color:#078;font-weight:bold">error</span>
    )

    <span style="color:#c0f">BeforeEach</span>(<span style="color:#069;font-weight:bold">func</span>() {
        book, err = <span style="color:#c0f">NewBookFromJSON</span>(<span style="color:#c30">`{
</span><span style="color:#c30">            &#34;title&#34;:&#34;Les Miserables&#34;,
</span><span style="color:#c30">            &#34;author&#34;:&#34;Victor Hugo&#34;,
</span><span style="color:#c30">            &#34;pages&#34;:1488
</span><span style="color:#c30">        }`</span>)
    })

    <span style="color:#c0f">Describe</span>(<span style="color:#c30">&#34;loading from JSON&#34;</span>, <span style="color:#069;font-weight:bold">func</span>() {
        <span style="color:#c0f">Context</span>(<span style="color:#c30">&#34;when the JSON fails to parse&#34;</span>, <span style="color:#069;font-weight:bold">func</span>() {
            <span style="color:#c0f">BeforeEach</span>(<span style="color:#069;font-weight:bold">func</span>() {
                book, err = <span style="color:#c0f">NewBookFromJSON</span>(<span style="color:#c30">`{
</span><span style="color:#c30">                    &#34;title&#34;:&#34;Les Miserables&#34;,
</span><span style="color:#c30">                    &#34;author&#34;:&#34;Victor Hugo&#34;,
</span><span style="color:#c30">                    &#34;pages&#34;:1488oops
</span><span style="color:#c30">                }`</span>)
            })

            <span style="color:#c0f">It</span>(<span style="color:#c30">&#34;should return the zero-value for the book&#34;</span>, <span style="color:#069;font-weight:bold">func</span>() {
                <span style="color:#c0f">Expect</span>(book).<span style="color:#c0f">To</span>(<span style="color:#c0f">BeZero</span>())
            })

            <span style="color:#c0f">It</span>(<span style="color:#c30">&#34;should error&#34;</span>, <span style="color:#069;font-weight:bold">func</span>() {
                <span style="color:#c0f">Expect</span>(err).<span style="color:#c0f">To</span>(<span style="color:#c0f">HaveOccurred</span>())
            })
        })
    })
})
</code></pre></td></tr></table>
</div>
</div><p>BDD 框架中一般都包含 <code>Describe</code>、<code>Context</code> 以及 <code>It</code> 等代码块，其中 <code>Describe</code> 的作用是描述代码的独立行为、<code>Context</code> 是在一个独立行为中的多个不同上下文，最后的 <code>It</code> 用于描述期望的行为，这些代码块最终都构成了类似『描述……，当……时，它应该……』的句式帮助我们快速地理解测试代码。</p>
<h3 id="mock-方法">Mock 方法</h3>
<p>项目中的单元测试应该是稳定的并且不依赖任何的外部项目，它只是对项目中函数和方法的测试，所以我们需要在单元测试中对所有的第三方的不稳定依赖进行 Mock，也就是模拟这些第三方服务的接口；除此之外，为了简化一次单元测试的上下文，在同一个项目中我们也会对其他模块进行  Mock，模拟这些依赖模块的返回值。</p>
<p>单元测试的核心就是隔离依赖并验证输入和输出的正确性，Go 语言作为一个静态语言提供了比较少的运行时特性，这也让我们在 Go 语言中 Mock 依赖变得非常困难。</p>
<p>Mock  的主要作用就是保证待测试方法依赖的上下文固定，在这时无论我们对当前方法运行多少次单元测试，如果业务逻辑不改变，它都应该返回完全相同的结果，在具体介绍 Mock 的不同方法之前，我们首先要清楚一些常见的依赖，一个函数或者方法的常见依赖可以有以下几种：</p>
<ol>
<li>接口</li>
<li>数据库</li>
<li>HTTP 请求</li>
<li>Redis、缓存以及其他依赖</li>
</ol>
<p>这些不同的场景基本涵盖了写单元测试时会遇到的情况，我们会在接下来的内容中分别介绍如何处理以上几种不同的依赖。</p>
<h4 id="接口-1">接口</h4>
<p>首先要介绍的其实就是 Go 语言中最常见也是最通用的 Mock 方法，也就是能够对接口进行 Mock 的 <a href="https://github.com/golang/mock">golang/mock</a> 框架，它能够根据接口生成 Mock 实现，假设我们有以下代码：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> blog

<span style="color:#069;font-weight:bold">type</span> Post <span style="color:#069;font-weight:bold">struct</span> {}

<span style="color:#069;font-weight:bold">type</span> Blog <span style="color:#069;font-weight:bold">interface</span> {
	<span style="color:#c0f">ListPosts</span>() []Post
}

<span style="color:#069;font-weight:bold">type</span> jekyll <span style="color:#069;font-weight:bold">struct</span> {}

<span style="color:#069;font-weight:bold">func</span> (b <span style="color:#555">*</span>jekyll) <span style="color:#c0f">ListPosts</span>() []Post {
 	<span style="color:#069;font-weight:bold">return</span> []Post{}
}

<span style="color:#069;font-weight:bold">type</span> wordpress <span style="color:#069;font-weight:bold">struct</span>{}

<span style="color:#069;font-weight:bold">func</span> (b <span style="color:#555">*</span>wordpress) <span style="color:#c0f">ListPosts</span>() []Post {
	<span style="color:#069;font-weight:bold">return</span> []Post{}
}
</code></pre></td></tr></table>
</div>
</div><p>我们的博客可能使用 <code>jekyll</code> 或者 <code>wordpress</code> 作为引擎，但是它们都会提供 <code>ListsPosts</code> 方法用于返回全部的文章列表，在这时我们就需要定义一个 <code>Post</code> 接口，接口要求遵循 <code>Blog</code> 的结构体必须实现 <code>ListPosts</code> 方法。</p>
<p><img src="https://img.draveness.me/golang-interface-blog-example.png" alt="golang-interface-blog-example"></p>
<p>当我们定义好了 <code>Blog</code> 接口之后，上层 <code>Service</code> 就不再需要依赖某个具体的博客引擎实现了，只需要依赖 <code>Blog</code> 接口就可以完成对文章的批量获取功能：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">package</span> service

<span style="color:#069;font-weight:bold">type</span> Service <span style="color:#069;font-weight:bold">interface</span> {
	<span style="color:#c0f">ListPosts</span>() ([]Post, <span style="color:#078;font-weight:bold">error</span>)
}

<span style="color:#069;font-weight:bold">type</span> service <span style="color:#069;font-weight:bold">struct</span> {
    blog blog.Blog
}

<span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">NewService</span>(b blog.Blog) <span style="color:#555">*</span>Service {
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#555">&amp;</span>service{
        blog: b,
    }
}

<span style="color:#069;font-weight:bold">func</span> (s <span style="color:#555">*</span>service) <span style="color:#c0f">ListPosts</span>() ([]Post, <span style="color:#078;font-weight:bold">error</span>) {
    <span style="color:#069;font-weight:bold">return</span> s.blog.<span style="color:#c0f">ListPosts</span>(), <span style="color:#069;font-weight:bold">nil</span>
}
</code></pre></td></tr></table>
</div>
</div><p>如果我们想要对 <code>Service</code> 进行测试，我们就可以使用 gomock 提供的 <code>mockgen</code> 工具命令生成 <code>MockBlog</code> 结构体，使用如下所示的命令：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#a00;background-color:#faa">$</span> mockgen <span style="color:#555">-</span><span style="color:#069;font-weight:bold">package</span>=mblog <span style="color:#555">-</span>source=pkg<span style="color:#555">/</span>blog<span style="color:#555">/</span>blog.<span style="color:#069;font-weight:bold">go</span> &gt; test<span style="color:#555">/</span>mocks<span style="color:#555">/</span>blog<span style="color:#555">/</span>blog.<span style="color:#069;font-weight:bold">go</span>

<span style="color:#a00;background-color:#faa">$</span> cat test<span style="color:#555">/</span>mocks<span style="color:#555">/</span>blog<span style="color:#555">/</span>blog.<span style="color:#069;font-weight:bold">go</span>
<span style="color:#09f;font-style:italic">// Code generated by MockGen. DO NOT EDIT.
</span><span style="color:#09f;font-style:italic">// Source: blog.go
</span><span style="color:#09f;font-style:italic"></span>
<span style="color:#09f;font-style:italic">// Package mblog is a generated GoMock package.
</span><span style="color:#09f;font-style:italic"></span><span style="color:#555">...</span>
<span style="color:#09f;font-style:italic">// NewMockBlog creates a new mock instance
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">NewMockBlog</span>(ctrl <span style="color:#555">*</span>gomock.Controller) <span style="color:#555">*</span>MockBlog {
	mock <span style="color:#555">:=</span> <span style="color:#555">&amp;</span>MockBlog{ctrl: ctrl}
	mock.recorder = <span style="color:#555">&amp;</span>MockBlogMockRecorder{mock}
	<span style="color:#069;font-weight:bold">return</span> mock
}

<span style="color:#09f;font-style:italic">// EXPECT returns an object that allows the caller to indicate expected use
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> (m <span style="color:#555">*</span>MockBlog) <span style="color:#c0f">EXPECT</span>() <span style="color:#555">*</span>MockBlogMockRecorder {
	<span style="color:#069;font-weight:bold">return</span> m.recorder
}

<span style="color:#09f;font-style:italic">// ListPosts mocks base method
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> (m <span style="color:#555">*</span>MockBlog) <span style="color:#c0f">ListPosts</span>() []Post {
	m.ctrl.T.<span style="color:#c0f">Helper</span>()
	ret <span style="color:#555">:=</span> m.ctrl.<span style="color:#c0f">Call</span>(m, <span style="color:#c30">&#34;ListPosts&#34;</span>)
	ret0, _ <span style="color:#555">:=</span> ret[<span style="color:#f60">0</span>].([]Post)
	<span style="color:#069;font-weight:bold">return</span> ret0
}

<span style="color:#09f;font-style:italic">// ListPosts indicates an expected call of ListPosts
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">func</span> (mr <span style="color:#555">*</span>MockBlogMockRecorder) <span style="color:#c0f">ListPosts</span>() <span style="color:#555">*</span>gomock.Call {
	mr.mock.ctrl.T.<span style="color:#c0f">Helper</span>()
	<span style="color:#069;font-weight:bold">return</span> mr.mock.ctrl.<span style="color:#c0f">RecordCallWithMethodType</span>(mr.mock, <span style="color:#c30">&#34;ListPosts&#34;</span>, reflect.<span style="color:#c0f">TypeOf</span>((<span style="color:#555">*</span>MockBlog)(<span style="color:#069;font-weight:bold">nil</span>).ListPosts))
}
</code></pre></td></tr></table>
</div>
</div><p>这段 <code>mockgen</code> 生成的代码非常长的，所以我们只展示了其中的一部分，它的功能就是帮助我们验证任意接口的输入参数并且模拟接口的返回值；而在生成 Mock 实现的过程中，作者总结了一些可以分享的经验：</p>
<ol>
<li>
<p>在 <code>test/mocks</code> 目录中放置所有的 Mock 实现，子目录与接口所在文件的二级目录相同，在这里源文件的位置在 <code>pkg/blog/blog.go</code>，它的二级目录就是 <code>blog/</code>，所以对应的 Mock 实现会被生成到 <code>test/mocks/blog/</code> 目录中；</p>
</li>
<li>
<p>指定 <code>package</code> 为 <code>mxxx</code>，默认的 <code>mock_xxx</code> 看起来非常冗余，上述 <code>blog</code> 包对应的 Mock 包也就是 <code>mblog</code>；</p>
</li>
<li>
<p><code>mockgen</code> 命令放置到 <code>Makefile</code> 中的 <code>mock</code> 下统一管理，减少祖传命令的出现；</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash">mock：
    rm -rf test/mocks

    mkdir -p test/mocks/blog
    mockgen -package<span style="color:#555">=</span>mblog -source<span style="color:#555">=</span>pkg/blog/blog.go &gt; test/mocks/blog/blog.go
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>当我们生成了上述的 Mock 实现代码之后，就可以使用如下的方式为 <code>Service</code> 写单元测试了，这段代码通过 <code>NewMockBlog</code> 生成一个 <code>Blog</code> 接口的 Mock 实现，然后通过 <code>EXPECT</code> 方法控制该实现会在调用 <code>ListPosts</code> 时返回空的 <code>Post</code> 数组：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestListPosts</span>(t <span style="color:#555">*</span>testing.T) {
	ctrl <span style="color:#555">:=</span> gomock.<span style="color:#c0f">NewController</span>(t)
	<span style="color:#069;font-weight:bold">defer</span> ctrl.<span style="color:#c0f">Finish</span>()

 	mockBlog <span style="color:#555">:=</span> mblog.<span style="color:#c0f">NewMockBlog</span>(ctrl)
 	mockBlog.<span style="color:#c0f">EXPECT</span>().<span style="color:#c0f">ListPosts</span>().<span style="color:#c0f">Return</span>([]Post{})
  
 	service <span style="color:#555">:=</span> <span style="color:#c0f">NewService</span>(mockBlog)
  
 	assert.<span style="color:#c0f">Equal</span>(t, []Post{}, service.<span style="color:#c0f">ListPosts</span>())
}
</code></pre></td></tr></table>
</div>
</div><p>由于当前 <code>Service</code> 只依赖于 <code>Blog</code> 的实现，所以在这时我们就能够断言当前方法一定会返回 <code>[]Post{}</code>，这时我们的方法的返回值就只与传入的参数有关（虽然 <code>ListPosts</code> 方法没有入参)，我们能够减少一次关注的上下文并保证测试的稳定和可信。</p>
<p>这是 Go 语言中最标准的单元测试写法，所有依赖的 <code>package</code> 无论是项目内外都应该使用这种方式处理（在有接口的情况下），如果没有接口 Go 语言的单元测试就会非常难写，这也是为什么从项目中是否有接口就能判断工程质量的原因了。</p>
<h4 id="sql">SQL</h4>
<p>另一个项目中比较常见的依赖其实就是数据库，在遇到数据库的依赖时，我们一般都会使用 <a href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a> 来模拟数据库的连接，当我们使用 sqlmock 时会写出如下所示的单元测试：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> (s <span style="color:#555">*</span>suiteServerTester) <span style="color:#c0f">TestRemovePost</span>() {
	entry <span style="color:#555">:=</span> pb.Post{
		Id: <span style="color:#f60">1</span>,
	}

	rows <span style="color:#555">:=</span> sqlmock.<span style="color:#c0f">NewRows</span>([]<span style="color:#078;font-weight:bold">string</span>{<span style="color:#c30">&#34;id&#34;</span>, <span style="color:#c30">&#34;author&#34;</span>}).<span style="color:#c0f">AddRow</span>(<span style="color:#f60">1</span>, <span style="color:#c30">&#34;draveness&#34;</span>)

	s.Mock.<span style="color:#c0f">ExpectQuery</span>(<span style="color:#c30">`SELECT (.+) FROM &#34;posts&#34;`</span>).<span style="color:#c0f">WillReturnRows</span>(rows)
	s.Mock.<span style="color:#c0f">ExpectExec</span>(<span style="color:#c30">`DELETE FROM &#34;posts&#34;`</span>).
		<span style="color:#c0f">WithArgs</span>(<span style="color:#f60">1</span>).
		<span style="color:#c0f">WillReturnResult</span>(sqlmock.<span style="color:#c0f">NewResult</span>(<span style="color:#f60">1</span>, <span style="color:#f60">1</span>))

	response, err <span style="color:#555">:=</span> s.server.<span style="color:#c0f">RemovePost</span>(context.<span style="color:#c0f">Background</span>(), <span style="color:#555">&amp;</span>entry)

	s.<span style="color:#c0f">NoError</span>(err)
	s.<span style="color:#c0f">EqualValues</span>(response, <span style="color:#555">&amp;</span>entry)
	s.<span style="color:#c0f">NoError</span>(s.Mock.<span style="color:#c0f">ExpectationsWereMet</span>())
}
</code></pre></td></tr></table>
</div>
</div><p>最常用的几个方法就是 <code>ExpectQuery</code> 和 <code>ExpectExec</code>，前者主要用于模拟 SQL 的查询语句，后者用于模拟 SQL 的增删，从上面的实例中我们可以看到这个这两种方法的使用方式，建议各位先阅读相关的 <a href="https://github.com/DATA-DOG/go-sqlmock">文档</a> 再尝试使用。</p>
<h4 id="http">HTTP</h4>
<p>HTTP 请求也是我们在项目中经常会遇到的依赖，<a href="https://github.com/jarcoal/httpmock">httpmock</a> 就是一个用于 Mock 所有 HTTP 依赖的包，它使用模式匹配的方式匹配 HTTP 请求的 URL，在匹配到特定的请求时就会返回预先设置好的响应。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestFetchArticles</span>(t <span style="color:#555">*</span>testing.T) {
	httpmock.<span style="color:#c0f">Activate</span>()
	<span style="color:#069;font-weight:bold">defer</span> httpmock.<span style="color:#c0f">DeactivateAndReset</span>()

	httpmock.<span style="color:#c0f">RegisterResponder</span>(<span style="color:#c30">&#34;GET&#34;</span>, <span style="color:#c30">&#34;https://api.mybiz.com/articles&#34;</span>,
		httpmock.<span style="color:#c0f">NewStringResponder</span>(<span style="color:#f60">200</span>, <span style="color:#c30">`[{&#34;id&#34;: 1, &#34;name&#34;: &#34;My Great Article&#34;}]`</span>))

	httpmock.<span style="color:#c0f">RegisterResponder</span>(<span style="color:#c30">&#34;GET&#34;</span>, <span style="color:#c30">`=~^https://api\.mybiz\.com/articles/id/\d+\z`</span>,
		httpmock.<span style="color:#c0f">NewStringResponder</span>(<span style="color:#f60">200</span>, <span style="color:#c30">`{&#34;id&#34;: 1, &#34;name&#34;: &#34;My Great Article&#34;}`</span>))

	<span style="color:#555">...</span>
}
</code></pre></td></tr></table>
</div>
</div><p>如果遇到 HTTP 请求的依赖时，就可以使用上述 <a href="https://github.com/jarcoal/httpmock">httpmock</a> 包模拟依赖的 HTTP 请求。</p>
<h4 id="猴子补丁">猴子补丁</h4>
<p>最后要介绍的猴子补丁其实就是一个大杀器了，<a href="https://github.com/bouk/monkey">bouk/monkey</a> 能够通过替换函数指针的方式修改<strong>任意函数</strong>的实现，所以如果上述的几种方法都不能满足我们的需求，我们就只能够通过猴子补丁这种比较 hack 的方法 Mock 依赖了：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">main</span>() {
	monkey.<span style="color:#c0f">Patch</span>(fmt.Println, <span style="color:#069;font-weight:bold">func</span>(a <span style="color:#555">...</span><span style="color:#069;font-weight:bold">interface</span>{}) (n <span style="color:#078;font-weight:bold">int</span>, err <span style="color:#078;font-weight:bold">error</span>) {
		s <span style="color:#555">:=</span> <span style="color:#366">make</span>([]<span style="color:#069;font-weight:bold">interface</span>{}, <span style="color:#366">len</span>(a))
		<span style="color:#069;font-weight:bold">for</span> i, v <span style="color:#555">:=</span> <span style="color:#069;font-weight:bold">range</span> a {
			s[i] = strings.<span style="color:#c0f">Replace</span>(fmt.<span style="color:#c0f">Sprint</span>(v), <span style="color:#c30">&#34;hell&#34;</span>, <span style="color:#c30">&#34;*bleep*&#34;</span>, <span style="color:#555">-</span><span style="color:#f60">1</span>)
		}
		<span style="color:#069;font-weight:bold">return</span> fmt.<span style="color:#c0f">Fprintln</span>(os.Stdout, s<span style="color:#555">...</span>)
	})
	fmt.<span style="color:#c0f">Println</span>(<span style="color:#c30">&#34;what the hell?&#34;</span>) <span style="color:#09f;font-style:italic">// what the *bleep*?
</span><span style="color:#09f;font-style:italic"></span>}
</code></pre></td></tr></table>
</div>
</div><p>然而这种方法的使用其实有一些限制，由于它是在运行时替换了函数的指针，所以如果遇到一些简单的函数，例如 <code>rand.Int63n</code> 和 <code>time.Now</code>，编译器可能会直接将这种函数内联到调用实际发生的代码处并不会调用原有的方法，所以使用这种方式往往需要我们在测试时额外指定 <code>-gcflags=-l</code> 禁止编译器的内联优化。</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-bash" data-lang="bash">$ go <span style="color:#366">test</span> -gcflags<span style="color:#555">=</span>-l ./...
</code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/bouk/monkey">bouk/monkey</a> 的 README 对于它的使用给出了一些注意事项，除了内联编译之外，我们需要注意的是<strong>不要在单元测试之外的地方使用猴子补丁</strong>，我们应该只在必要的时候使用这种方法，例如依赖的第三方库没有提供 <code>interface</code> 或者修改 <code>time.Now</code> 以及 <code>rand.Int63n</code> 等内置函数的返回值用于测试时。</p>
<p>从理论上来说，通过猴子补丁这种方式我们能够在运行时 Mock Go 语言中的一切函数，这也为我们提供了单元测试 Mock 依赖的最终解决方案。</p>
<h3 id="断言">断言</h3>
<p>在最后，我们简单介绍一下辅助单元测试的 <a href="https://github.com/stretchr/testify">assert</a> 包，它提供了非常多的断言方法帮助我们快速对期望的返回值进行测试，减少我们的工作量：</p>
<div class="highlight"><div style="background-color:#f0f3f3">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre style="background-color:#f0f3f3"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre style="background-color:#f0f3f3"><code class="language-go" data-lang="go"><span style="color:#069;font-weight:bold">func</span> <span style="color:#c0f">TestSomething</span>(t <span style="color:#555">*</span>testing.T) {
  assert.<span style="color:#c0f">Equal</span>(t, <span style="color:#f60">123</span>, <span style="color:#f60">123</span>, <span style="color:#c30">&#34;they should be equal&#34;</span>)

  assert.<span style="color:#c0f">NotEqual</span>(t, <span style="color:#f60">123</span>, <span style="color:#f60">456</span>, <span style="color:#c30">&#34;they should not be equal&#34;</span>)

  assert.<span style="color:#c0f">Nil</span>(t, object)

  <span style="color:#069;font-weight:bold">if</span> assert.<span style="color:#c0f">NotNil</span>(t, object) {
    assert.<span style="color:#c0f">Equal</span>(t, <span style="color:#c30">&#34;Something&#34;</span>, object.Value)
  }
}
</code></pre></td></tr></table>
</div>
</div><p>在这里我们也是简单展示一下 <code>assert</code> 的示例，更详细的内容可以阅读它的相关文档，在这里也就不多做展示了。</p>
<h3 id="小结-4">小结</h3>
<p>如果之前完全没有写过单元测试或者没有写过 Go 语言的单元测试，相信这篇文章已经给了足够多的上下文帮助我们开始做这件事情，我们要知道的是单元测试其实并不会阻碍我们的开发进度，它能够为我们的上线提供信心，也是质量保证上投资回报率最高的方法。</p>
<p>学习写好单元测试一定会有一些学习曲线和不适应，甚至会在短期内影响我们的开发效率，但是熟悉了这一套流程和接口之后，单元测试对我们的帮助会非常大，每一个单元测试都表示一个业务逻辑，每次提交时执行单元测试就能够帮助我们确定新的代码大概率上不会影响已有的业务逻辑，能够明显地降低重构的风险以及线上事故的数量</p>
<h2 id="总结">总结</h2>
<p>在这篇文章中我们从三个方面分别介绍了如何写优雅的 Go 语言代码，作者尽可能地给出了最容易操作和最有效的方法：</p>
<ul>
<li>代码规范：使用辅助工具帮助我们在每次提交 PR 时自动化地对代码进行检查，减少工程师人工审查的工作量；</li>
<li>最佳实践
<ul>
<li>目录结构：遵循 Go 语言社区中被广泛达成共识的 <a href="https://github.com/golang-standards/project-layout">目录结构</a>，减少项目的沟通成本；</li>
<li>模块拆分：按照职责对不同的模块进行拆分，Go 语言的项目中也不应该出现 <code>model</code>、<code>controller</code> 这种违反语言顶层设计思路的包名；</li>
<li>显示与隐式：尽可能地消灭项目中的 <code>init</code> 函数，保证显式地进行方法的调用以及错误的处理；</li>
<li>面向接口：面向接口是 Go 语言鼓励的开发方式，也能够为我们写单元测试提供方便，我们应该遵循固定的模式对外提供功能；
<ol>
<li>使用大写的 <code>Service</code> 对外暴露方法；</li>
<li>使用小写的 <code>service</code> 实现接口中定义的方法；</li>
<li>通过 <code>func NewService(...) (Service, error)</code> 函数初始化 <code>Service</code> 接口；</li>
</ol>
</li>
</ul>
</li>
<li>单元测试：保证项目工程质量的最有效办法；
<ul>
<li>可测试：意味着面向接口编程以及减少单个函数中包含的逻辑，使用『小方法』；</li>
<li>组织方式：使用 Go 语言默认的 Test 框架、开源的 <code>suite</code> 或者 BDD 的风格对单元测试进行合理组织；</li>
<li>Mock 方法：四种不同的单元测试 Mock 方法；
<ul>
<li><a href="https://github.com/golang/mock">gomock</a>：最标准的也是最被鼓励的方式；</li>
<li><a href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a>：处理依赖的数据库；</li>
<li><a href="https://github.com/jarcoal/httpmock">httpmock</a>：处理依赖的 HTTP 请求；</li>
<li><a href="https://github.com/bouk/monkey">monkey</a>：万能的方法，但是只在万不得已时使用，类似的代码写起来非常冗长而且不直观；</li>
</ul>
</li>
<li>断言：使用社区的 <a href="https://github.com/stretchr/testify">testify</a> 快速验证方法的返回值；</li>
</ul>
</li>
</ul>
<p>想要写出优雅的代码本身就不是一件容易的事情，它需要我们不断地对自己的知识体系进行更新和优化，推倒之前的经验并对项目持续进行完善和重构，而只有真正经过思考和设计的代码才能够经过时间的检验（代码是需要不断重构的），随意堆砌代码的行为是不能鼓励也不应该发生的，每一行代码都应该按照最高的标准去设计和开发，这是我们保证工程质量的唯一方法。</p>
<p>作者也一直在努力学习如何写出更加优雅的代码，写出好的代码真的不是一件容易的事情，作者也希望能通过这篇文章帮助使用工程师写出更有 Go 语言风格的项目。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="http://goinbigdata.com/goimports-vs-gofmt/">goimports vs gofmt</a></li>
<li><a href="https://rakyll.org/style-packages/">Style guideline for Go packages</a></li>
<li><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">Standard Package Layout</a></li>
<li><a href="https://stackoverflow.com/questions/41571946/internal-packages-in-go">Internal packages in Go</a></li>
<li><a href="https://golang.org/doc/effective_go.html#init">The init function · Effective Go</a></li>
</ul>
<h2 id="推荐阅读">推荐阅读</h2>
<p>如果你对 Go 语言的设计原理、实现原理比较感兴趣，可以阅读 <a href="https://draveness.me/golang/">Go 语言设计与实现</a> 了解更多的内容。</p>
<blockquote>
<p>Go 语言是 Google 在 2009 年 12 月发布的编程语言，目前的 Go 语言在国内外的社区都非常热门，很多著名的开源框架  Kubernetes、etcd 和 prometheus 等都使用 Go 语言进行开发，近年来热门的微服务架构和云原生技术也为 Go  语言社区带来了非常多的活力。</p>
<p>作者目前也使用 Go 语言作为日常开发的主要语言，虽然 Go 语言没有 Lisp 系语言的开发效率和强大表达能力，但是却是一门非常容易使用并且大规模运用的工程语言，这也是作者学习和使用 Go 语言的主要原因。</p>
<p>这本书介绍的主要内容其实就是 Go 语言的设计原理与实现，其中包括 Go 语言的编译过程、关键字、运行时、调度器、内存分配等内容。</p>
</blockquote>

                
                
                <hr> 

<div class="entry-shang text-center">
    
    <p> 「真诚赞赏，手留余香」</p>
    
    <button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
    <div class="zs-modal-head">
        <button type="button" class="close">×</button>
        <span class="author">
            <a href="https://hollson.github.io">
                <img src="https://hollson.github.io/img/reward/hollson.png" alt="史布斯" />码夫庄园
            </a>
        </span>
        
        <p class="tip"><i></i><span>嗯，我的梦想是被读者的稿费包养~</span></p>
        

    </div>
    <div class="zs-modal-body">
        <div class="zs-modal-btns">
            <button class="btn btn-blink" data-num="2">2元</button>
            <button class="btn btn-blink" data-num="5">5元</button>
            <button class="btn btn-blink" data-num="10">10元</button>
            <button class="btn btn-blink" data-num="50">50元</button>
            <button class="btn btn-blink" data-num="100">100元</button>
            <button class="btn btn-blink" data-num="1">任意金额</button>
        </div>
        <div class="zs-modal-pay">
            <button class="btn btn-bred" id="pay-text">2元</button>
            <p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
            <img src="https://hollson.github.io/img/reward/wechat-2.png" alt="史布斯" id="pay-image" />
        </div>
    </div>
    <div class="zs-modal-footer">
        <label>
            <span class="zs-wechat"></span>
            <input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked">
            <img src="https://hollson.github.io/img/reward/wechat-btn.png" alt="史布斯" />
            </span>&nbsp;
            <span>
                <input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay">
                <img src="https://hollson.github.io/img/reward/alipay-btn.png" alt="史布斯" />
            </span>
        </label>
    </div>
</div>

 

                <br>
                <br>

            </div>

        </div>
    </div>
    <div class="column is-3">
        <div class="card">
    <div class="card-content">
        <h2 class="title is-6">最近发布</h2>
        
        <h2><a class="is-size-6" href="https://hollson.github.io/posts/0742b474a643d63a774461726a6201203/">Go语言中的原子操作</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年12月2日 </time>
         
        <h2><a class="is-size-6" href="https://hollson.github.io/posts/1600330472/">Go基础笔记 - 2.3 常量</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年9月10日 </time>
         
        <h2><a class="is-size-6" href="https://hollson.github.io/posts/15996311192/">Go - Gin框架快速入门</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年9月9日 </time>
         
        <h2><a class="is-size-6" href="https://hollson.github.io/post/1597480249/">Gorm快速指南</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年8月14日 </time>
         
        <h2><a class="is-size-6" href="https://hollson.github.io/post/1597480218/">18. Go语言MySQL数据库操作</a></h2>
        
        <time class="has-text-grey-light is-size-7">2020年8月14日 </time>
         
    </div>
</div>
<br>
        


        <div class="card">
    <div class="card-content">
        <h2 class="title is-6">标签</h2>
        <div>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/atomic">atomic</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/blog">blog</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/cgo">cgo</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/cloud">cloud</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/config">config</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/copy">copy</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/docker">docker</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/exam">exam</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/gin">gin</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/git">git</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/golang">golang</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/hugo">hugo</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/install">install</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/istio">istio</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/jenkins">jenkins</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/kubernetes">kubernetes</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/map">map</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/microservice">microservice</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/mycat">mycat</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/nginx">nginx</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/plan9">plan9</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/posix">posix</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/proxy">proxy</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/raft">raft</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/ssh">ssh</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/tips">tips</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/ymal">ymal</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E4%B8%BB%E4%BB%8E">主从</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E4%BA%8B%E5%8A%A1">事务</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E4%BB%A3%E7%90%86">代理</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%86%85%E5%AD%98">内存</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%8E%8B%E7%BC%A9">压缩</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%8E%9F%E5%88%9B">原创</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%8E%9F%E5%AD%90">原子</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C">命令行</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%93%A8%E5%85%B5">哨兵</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%AD%98%E5%82%A8">存储</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%B8%B8%E9%87%8F">常量</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%B9%B6%E5%8F%91">并发</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%BC%82%E5%B8%B8">异常</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81">授权认证</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%8E%92%E5%BA%8F">排序</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%8E%A5%E5%8F%A3">接口</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%97%A5%E5%BF%97">日志</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%9D%83%E9%99%90">权限</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%A0%87%E7%AD%BE1">标签1</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%A0%87%E7%AD%BE2">标签2</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%AD%A3%E5%88%99">正则</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91">流量分发</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%B5%8B%E8%AF%95">测试</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E6%BA%90%E7%A0%81">源码</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E7%8A%B6%E6%80%81%E7%A0%81">状态码</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E7%AE%97%E6%B3%95">算法</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F">编程模式</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E8%80%81%E5%A6%96%E7%AC%94%E8%AE%B0">老妖笔记</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%80%83%E9%80%B8">逃逸</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%85%8D%E7%BD%AE">配置</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%87%8D%E5%86%99">重写</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%9B%86%E7%BE%A4">集群</a>
            </span>
            
            <span class="tag is-size-7">
                <a href="https://hollson.github.io/tags/%E9%9D%A2%E8%AF%95">面试</a>
            </span>
            
        </div>
    </div>
</div>
<br>
    </div>
</div>

        </div>
    </div>

    
    <footer class="footer has-background-grey-darker has-text-white">
    <div class="content has-text-centered">
        <p>
            <span class="icon is-large">
                <a href="https://twitter.com/" class="mysocial" rel="me">
                    <i class="fab fa-twitter fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <span class="icon is-large">
                <a href="https://www.youtube.com/" class="mysocial" rel="me">
                    <i class="fab fa-youtube fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <span class="icon is-large">
                <a href="https://github.com/" class="mysocial" rel="me">
                    <i class="fab fa-github fa-3x"></i></a>
            </span>&nbsp;&nbsp;
            <br><br>
            友情链接：
            
            <a class="mysocial" href="http://www.mafool.com" target="_blank">Mafool</a>
            
            <a class="mysocial" href="https://gohugo.io/documentation/" target="_blank">Hugo</a>
            
            <a class="mysocial" href="https://bulma.io/" target="_blank">Bulma</a>
            
            <a class="mysocial" href="https://bootstrapious.com/" target="_blank">Bootstrapious</a>
            
            <a class="mysocial" href="https://youzhixueyuan.com/" target="_blank">Youzhixueyuan</a>
            
            <br><br />
            版权所有 &copy; 码夫庄园 2021
            - <a class="mysocial" href="https://github.com/hollson/hugo-theme-dooz">Hugo Theme</a>
        </p>
    </div>
</footer>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='https://hollson.github.io/js/dooz.totop.js?v=0.0.0' async=""></script>


<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = 'https://hm.baidu.com/hm.js?f185359ec6b829a6a93e1e1f2597f6d9';
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-DK042XSJ2J"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-DK042XSJ2J');
</script>

    
    
<script type="text/javascript" src="https://hollson.github.io/js/reward.js"></script>

    
    <script defer src="https://cdn.staticfile.org/font-awesome/5.13.0/js/all.min.js"></script>
</body>

</html>